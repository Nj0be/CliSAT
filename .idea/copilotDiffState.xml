<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/AMTS.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/AMTS.h" />
              <option name="originalContent" value="//&#10;// Created by Beniamino Vagnarelli on 10/04/25.&#10;//&#10;&#10;#pragma once&#10;#include &lt;chrono&gt;&#10;#include &lt;random&gt;&#10;&#10;#include &quot;custom_bitset.h&quot;&#10;#include &quot;custom_graph.h&quot;&#10;&#10;inline std::pair&lt;custom_bitset, bool&gt; TS(const custom_graph&amp; g, std::vector&lt;uint64_t&gt;&amp; swap_mem, custom_bitset S, const uint64_t k, const uint64_t L, uint64_t&amp; Iter, const std::chrono::time_point&lt;std::chrono::steady_clock&gt; max_time) {&#10;    uint64_t I = 0; // iterations&#10;    custom_bitset S_max = S;&#10;    std::vector&lt;uint64_t&gt; tabu_list(g.size());&#10;&#10;    // TODO: move random generator out and pass it to everything&#10;    std::mt19937 rng(std::chrono::steady_clock::now().time_since_epoch().count());&#10;    std::uniform_real_distribution&lt;&gt; real_dist(0, 1);&#10;    std::uniform_int_distribution&lt;&gt; int_dist(0, INT32_MAX);&#10;&#10;    // TODO: instead of generate everything every loop, we can update the values&#10;    while (I &lt; L) {&#10;        if (std::chrono::steady_clock::now() &gt; max_time) break;&#10;&#10;        uint64_t old_S_edges = 0;&#10;        custom_bitset S_neg = ~S;&#10;        std::vector&lt;uint64_t&gt; A;&#10;        std::vector&lt;uint64_t&gt; A_without_tabu;&#10;        std::vector&lt;uint64_t&gt; B;&#10;        std::vector&lt;uint64_t&gt; B_without_tabu;&#10;        uint64_t MinInS = 0;&#10;        uint64_t MaxOutS = 0;&#10;        std::vector&lt;uint64_t&gt; d(g.size());&#10;        for (uint64_t v = 0; v &lt; g.size(); v++) {&#10;            d[v] = (g.get_neighbor_set(v) &amp; S).n_set_bits();&#10;            // removed tabu_list check, moved later on the code&#10;            if (S.get_bit(v)) {&#10;                if (d[v] &lt; MinInS) {&#10;                    MinInS = d[v];&#10;                    A.clear();&#10;                    A_without_tabu.clear();&#10;                }&#10;                A.emplace_back(v);&#10;                if (tabu_list[v] &lt;= I) A_without_tabu.emplace_back(v);&#10;            }&#10;            else if (S_neg.get_bit(v)) {&#10;                if (d[v] &gt; MaxOutS) {&#10;                    MaxOutS = d[v];&#10;                    B.clear();&#10;                    B_without_tabu.emplace_back(v);&#10;                }&#10;                B.emplace_back(v);&#10;                if (tabu_list[v] &lt;= I) B_without_tabu.emplace_back(v);&#10;            }&#10;            old_S_edges += d[v]; //we sum every vertex degree&#10;        }&#10;        old_S_edges /= 2; // we divide by 2 (we count 2 times)&#10;&#10;        std::vector&lt;std::pair&lt;uint64_t, uint64_t&gt;&gt; T;&#10;&#10;        for (auto u : A) {&#10;            for (auto v : B) {&#10;                if (!g.get_neighbor_set(u).get_bit(v)) {&#10;                    T.emplace_back(u, v);&#10;                }&#10;            }&#10;        }&#10;&#10;        int64_t u = 0;&#10;        int64_t v = 0;&#10;        int64_t delta = 0;&#10;&#10;        if (!T.empty()) {&#10;            std::tie(u, v) = T[int_dist(rng) % T.size()];&#10;            delta = d[v] - d[u];&#10;        } else {&#10;            //TODO: in small graphs it can happen&#10;            if (A_without_tabu.empty() || B_without_tabu.empty()) {&#10;                Iter++;&#10;                I++;&#10;                continue;&#10;            }&#10;            // if no better solution is found, we need to blacklist nodes in the tabu_list&#10;            u = A_without_tabu[int_dist(rng) % A_without_tabu.size()];&#10;            v = B_without_tabu[int_dist(rng) % B_without_tabu.size()];&#10;            delta = d[v] - d[u] - 1;&#10;        }&#10;&#10;        if (delta &lt;= 0) {&#10;            // probabilistic diversifying move selection rule&#10;            // with&#10;            uint64_t l = k*(k-1)/2 - old_S_edges;&#10;            const double p = std::min(static_cast&lt;double&gt;((l + 2)/g.size()), 0.1);&#10;            const double random = real_dist(rng);&#10;            if (random &lt;= p) {&#10;                auto rand_num = int_dist(rng) % S.n_set_bits();&#10;&#10;                // select u at random from S&#10;                auto new_u = S.first_bit();&#10;                for (uint64_t i = 1; i &lt; rand_num; i++) {&#10;                    new_u = S.next_bit();&#10;                }&#10;&#10;                // select v from V\S such that d[v] &lt; integer part of k*p&#10;                auto new_v = S_neg.first_bit();&#10;                while (new_v != S_neg.size()) {&#10;                    // TODO: doesn't work (doesn't always find a v)&#10;                    if (d[new_v] &lt; static_cast&lt;uint64_t&gt;(k*g.get_density())) break;&#10;                    new_v = S_neg.next_bit();&#10;                }&#10;                if (new_v != S_neg.size()) {&#10;                    u = new_u;&#10;                    v = new_v;&#10;                }&#10;            }&#10;        }&#10;&#10;        S.unset_bit(u);&#10;        S.set_bit(v);&#10;        swap_mem[u]++;&#10;        swap_mem[v]++;&#10;&#10;        auto S_edges = g.get_subgraph_edges(S);&#10;&#10;        // TODO: we consider old or updated S for l1 calculation?&#10;        auto l1 = k*(k-1)/2 - S_edges;&#10;        auto l = std::min(l1, 10UL);&#10;        uint64_t C = std::max(k/40, 6UL);&#10;&#10;        tabu_list[u] = I + l + (int_dist(rng)%C);&#10;        tabu_list[v] = I + 0.6*l + (int_dist(rng)%static_cast&lt;uint64_t&gt;(0.6 * C));&#10;&#10;        // update tabu list&#10;&#10;&#10;        // If S is a legal k clique&#10;        if (S_edges == k*(k-1)/2) { // legal k clique&#10;            return {S, true};&#10;        }&#10;        Iter++;&#10;&#10;        if (S_edges &gt; g.get_subgraph_edges(S_max)) {&#10;            S_max = S;&#10;            I = 0;&#10;        } else {&#10;            I++;&#10;        }&#10;    }&#10;&#10;    return {S_max, false};&#10;}&#10;&#10;inline std::pair&lt;custom_bitset, bool&gt; AMTS(const custom_graph&amp; g, const uint64_t k, const uint64_t L, const uint64_t Iter_max, const std::chrono::time_point&lt;std::chrono::steady_clock&gt; max_time) {&#10;    std::vector&lt;uint64_t&gt; swap_mem(g.size());&#10;    custom_bitset S(g.size());&#10;&#10;    // construct initial Solution&#10;    for (uint64_t i = 0; i &lt; k; i++) {&#10;        auto S_neg = ~S;&#10;        uint64_t OutMaxEdge = 0;&#10;&#10;        auto v = S_neg.first_bit();&#10;        auto selected_v = v;&#10;        while (v != S_neg.size()) {&#10;            auto v_edges = (g.get_neighbor_set(v) &amp; S).n_set_bits();&#10;            if (v_edges &gt; OutMaxEdge) {&#10;                OutMaxEdge = v_edges;&#10;                selected_v = v;&#10;            }&#10;&#10;            v = S_neg.next_bit();&#10;        }&#10;&#10;        S.set_bit(selected_v);&#10;    }&#10;&#10;    custom_bitset S_max(S);&#10;    uint64_t Iter = 0;&#10;    while (Iter &lt; Iter_max) {&#10;        if (std::chrono::steady_clock::now() &gt; max_time) break;&#10;&#10;        bool is_legal_k_clique = false;&#10;        std::tie(S_max, is_legal_k_clique) = TS(g, swap_mem, S, k, L, Iter, max_time);&#10;        if (is_legal_k_clique) return {S_max, true};&#10;&#10;        //else&#10;        S.unset_all();&#10;        auto least_frequent = std::distance(swap_mem.begin(),std::min(swap_mem.begin(), swap_mem.end()));&#10;        S.set_bit(least_frequent);&#10;&#10;        // TODO: can improve?&#10;        for (uint64_t i = 1; i &lt; k; i++) {&#10;            auto S_neg = ~S;&#10;            std::vector&lt;uint64_t&gt; candidates(g.size());&#10;            uint64_t OutMaxEdge = 0;&#10;&#10;            auto v = S_neg.first_bit();&#10;            while (v != S_neg.size()) {&#10;                auto v_edges = (g.get_neighbor_set(v) &amp; S).n_set_bits();&#10;                if (v_edges &gt; OutMaxEdge) {&#10;                    OutMaxEdge = v_edges;&#10;                    candidates.clear();&#10;                }&#10;                candidates.push_back(v);&#10;&#10;                v = S_neg.next_bit();&#10;            }&#10;&#10;            auto v_min = std::ranges::min_element(candidates.begin(), candidates.end(), [&amp;swap_mem](const uint64_t a, const uint64_t b) {&#10;                return swap_mem[a] &lt; swap_mem[b];&#10;            });&#10;&#10;            S.set_bit(*v_min);&#10;        }&#10;        if (*std::min(swap_mem.begin(), swap_mem.end()) &gt; k) {&#10;            std::ranges::fill(swap_mem, 0);&#10;        }&#10;    }&#10;&#10;    return { S_max, false };&#10;}&#10;&#10;inline custom_bitset run_AMTS(const custom_graph&amp; g, int64_t run_time=50) {&#10;    auto max_time = std::chrono::steady_clock::now() + std::chrono::milliseconds(run_time);&#10;    // TODO: get complement for p &lt; 0.5&#10;    uint64_t Iter_Max = 100000000;&#10;    custom_bitset S_max(g.size());&#10;    custom_bitset S(g.size());&#10;    for (uint64_t k = 1; k &lt; g.size(); k++) {&#10;        if (std::chrono::steady_clock::now() &gt; max_time) break;&#10;&#10;        uint64_t L = g.size() * k;&#10;        // if brock or san L = 4 * k;&#10;        bool is_legal_k_clique = false;&#10;        std::tie(S, is_legal_k_clique) = AMTS(g, k, L, Iter_Max, max_time);&#10;        if (!is_legal_k_clique) return S_max;&#10;        S_max = S;&#10;    }&#10;    return S_max;&#10;}&#10;" />
              <option name="updatedContent" value="//&#10;// Created by Beniamino Vagnarelli on 10/04/25.&#10;//&#10;&#10;#pragma once&#10;#include &lt;chrono&gt;&#10;#include &lt;random&gt;&#10;&#10;#include &quot;custom_bitset.h&quot;&#10;#include &quot;custom_graph.h&quot;&#10;&#10;inline std::pair&lt;custom_bitset, bool&gt; TS(const custom_graph&amp; g, std::vector&lt;uint64_t&gt;&amp; swap_mem, custom_bitset S, const uint64_t k, const uint64_t L, uint64_t&amp; Iter, const std::chrono::time_point&lt;std::chrono::steady_clock&gt; max_time) {&#10;    uint64_t I = 0; // iterations&#10;    custom_bitset S_max = S;&#10;    std::vector&lt;uint64_t&gt; tabu_list(g.size());&#10;&#10;    // TODO: move random generator out and pass it to everything&#10;    std::mt19937 rng(std::chrono::steady_clock::now().time_since_epoch().count());&#10;    std::uniform_real_distribution&lt;&gt; real_dist(0, 1);&#10;    std::uniform_int_distribution&lt;&gt; int_dist(0, INT32_MAX);&#10;&#10;    // TODO: instead of generate everything every loop, we can update the values&#10;    while (I &lt; L) {&#10;        if (std::chrono::steady_clock::now() &gt; max_time) break;&#10;&#10;        uint64_t old_S_edges = 0;&#10;        custom_bitset S_neg = ~S;&#10;        std::vector&lt;uint64_t&gt; A;&#10;        std::vector&lt;uint64_t&gt; A_without_tabu;&#10;        std::vector&lt;uint64_t&gt; B;&#10;        std::vector&lt;uint64_t&gt; B_without_tabu;&#10;        uint64_t MinInS = 0;&#10;        uint64_t MaxOutS = 0;&#10;        std::vector&lt;uint64_t&gt; d(g.size());&#10;        for (uint64_t v = 0; v &lt; g.size(); v++) {&#10;            d[v] = (g.get_neighbor_set(v) &amp; S).n_set_bits();&#10;            // removed tabu_list check, moved later on the code&#10;            if (S.get_bit(v)) {&#10;                if (d[v] &lt; MinInS) {&#10;                    MinInS = d[v];&#10;                    A.clear();&#10;                    A_without_tabu.clear();&#10;                }&#10;                A.emplace_back(v);&#10;                if (tabu_list[v] &lt;= I) A_without_tabu.emplace_back(v);&#10;            }&#10;            else if (S_neg.get_bit(v)) {&#10;                if (d[v] &gt; MaxOutS) {&#10;                    MaxOutS = d[v];&#10;                    B.clear();&#10;                    B_without_tabu.emplace_back(v);&#10;                }&#10;                B.emplace_back(v);&#10;                if (tabu_list[v] &lt;= I) B_without_tabu.emplace_back(v);&#10;            }&#10;            old_S_edges += d[v]; //we sum every vertex degree&#10;        }&#10;        old_S_edges /= 2; // we divide by 2 (we count 2 times)&#10;&#10;        std::vector&lt;std::pair&lt;uint64_t, uint64_t&gt;&gt; T;&#10;&#10;        for (auto u : A) {&#10;            for (auto v : B) {&#10;                if (!g.get_neighbor_set(u).get_bit(v)) {&#10;                    T.emplace_back(u, v);&#10;                }&#10;            }&#10;        }&#10;&#10;        int64_t u = 0;&#10;        int64_t v = 0;&#10;        int64_t delta = 0;&#10;&#10;        if (!T.empty()) {&#10;            std::tie(u, v) = T[int_dist(rng) % T.size()];&#10;            delta = d[v] - d[u];&#10;        } else {&#10;            //TODO: in small graphs it can happen&#10;            if (A_without_tabu.empty() || B_without_tabu.empty()) {&#10;                Iter++;&#10;                I++;&#10;                continue;&#10;            }&#10;            // if no better solution is found, we need to blacklist nodes in the tabu_list&#10;            u = A_without_tabu[int_dist(rng) % A_without_tabu.size()];&#10;            v = B_without_tabu[int_dist(rng) % B_without_tabu.size()];&#10;            delta = d[v] - d[u] - 1;&#10;        }&#10;&#10;        if (delta &lt;= 0) {&#10;            uint64_t l = k*(k-1)/2 - old_S_edges;&#10;            const double p = std::min(static_cast&lt;double&gt;((l + 2)/g.size()), 0.1);&#10;            const double random = real_dist(rng);&#10;            if (random &lt;= p) {&#10;                auto rand_num = int_dist(rng) % S.n_set_bits();&#10;&#10;                // select u at random from S&#10;                BitCursor new_u = S.first_bit();&#10;                for (uint64_t i = 1; i &lt; rand_num; i++) {&#10;                    new_u = S.next_bit(new_u);&#10;                }&#10;&#10;                // select v from V\S such that d[v] &lt; integer part of k*p&#10;                BitCursor new_v = S_neg.first_bit();&#10;                while (new_v.getPos() != S_neg.size()) {&#10;                    if (d[new_v.getPos()] &lt; static_cast&lt;uint64_t&gt;(k*g.get_density())) break;&#10;                    new_v = S_neg.next_bit(new_v);&#10;                }&#10;                if (new_v.getPos() != S_neg.size()) {&#10;                    u = new_u.getPos();&#10;                    v = new_v.getPos();&#10;                }&#10;            }&#10;        }&#10;&#10;        S.unset_bit(u);&#10;        S.set_bit(v);&#10;        swap_mem[u]++;&#10;        swap_mem[v]++;&#10;&#10;        auto S_edges = g.get_subgraph_edges(S);&#10;&#10;        // TODO: we consider old or updated S for l1 calculation?&#10;        auto l1 = k*(k-1)/2 - S_edges;&#10;        auto l = std::min(l1, 10UL);&#10;        uint64_t C = std::max(k/40, 6UL);&#10;&#10;        tabu_list[u] = I + l + (int_dist(rng)%C);&#10;        tabu_list[v] = I + 0.6*l + (int_dist(rng)%static_cast&lt;uint64_t&gt;(0.6 * C));&#10;&#10;        // update tabu list&#10;&#10;&#10;        // If S is a legal k clique&#10;        if (S_edges == k*(k-1)/2) { // legal k clique&#10;            return {S, true};&#10;        }&#10;        Iter++;&#10;&#10;        if (S_edges &gt; g.get_subgraph_edges(S_max)) {&#10;            S_max = S;&#10;            I = 0;&#10;        } else {&#10;            I++;&#10;        }&#10;    }&#10;&#10;    return {S_max, false};&#10;}&#10;&#10;inline std::pair&lt;custom_bitset, bool&gt; AMTS(const custom_graph&amp; g, const uint64_t k, const uint64_t L, const uint64_t Iter_max, const std::chrono::time_point&lt;std::chrono::steady_clock&gt; max_time) {&#10;    std::vector&lt;uint64_t&gt; swap_mem(g.size());&#10;    custom_bitset S(g.size());&#10;&#10;    // construct initial Solution&#10;    for (uint64_t i = 0; i &lt; k; i++) {&#10;        auto S_neg = ~S;&#10;        uint64_t OutMaxEdge = 0;&#10;&#10;        BitCursor v = S_neg.first_bit();&#10;        BitCursor selected_v = v;&#10;        while (v.getPos() != S_neg.size()) {&#10;            auto v_edges = (g.get_neighbor_set(v.getPos()) &amp; S).n_set_bits();&#10;            if (v_edges &gt; OutMaxEdge) {&#10;                OutMaxEdge = v_edges;&#10;                selected_v = v;&#10;            }&#10;&#10;            v = S_neg.next_bit(v);&#10;        }&#10;&#10;        S.set_bit(selected_v.getPos());&#10;    }&#10;&#10;    custom_bitset S_max(S);&#10;    uint64_t Iter = 0;&#10;    while (Iter &lt; Iter_max) {&#10;        if (std::chrono::steady_clock::now() &gt; max_time) break;&#10;&#10;        bool is_legal_k_clique = false;&#10;        std::tie(S_max, is_legal_k_clique) = TS(g, swap_mem, S, k, L, Iter, max_time);&#10;        if (is_legal_k_clique) return {S_max, true};&#10;&#10;        //else&#10;        S.unset_all();&#10;        auto least_frequent = std::distance(swap_mem.begin(),std::min(swap_mem.begin(), swap_mem.end()));&#10;        S.set_bit(least_frequent);&#10;&#10;        // TODO: can improve?&#10;        for (uint64_t i = 1; i &lt; k; i++) {&#10;            auto S_neg = ~S;&#10;            std::vector&lt;uint64_t&gt; candidates;&#10;            uint64_t OutMaxEdge = 0;&#10;&#10;            BitCursor v = S_neg.first_bit();&#10;            while (v.getPos() != S_neg.size()) {&#10;                auto v_edges = (g.get_neighbor_set(v.getPos()) &amp; S).n_set_bits();&#10;                if (v_edges &gt; OutMaxEdge) {&#10;                    OutMaxEdge = v_edges;&#10;                    candidates.clear();&#10;                }&#10;                candidates.push_back(v.getPos());&#10;&#10;                v = S_neg.next_bit(v);&#10;            }&#10;&#10;            auto v_min = std::ranges::min_element(candidates.begin(), candidates.end(),&#10;                [&amp;swap_mem](const uint64_t a, const uint64_t b) {&#10;                    return swap_mem[a] &lt; swap_mem[b];&#10;                });&#10;&#10;            S.set_bit(*v_min);&#10;        }&#10;        if (*std::min(swap_mem.begin(), swap_mem.end()) &gt; k) {&#10;            std::ranges::fill(swap_mem, 0);&#10;        }&#10;    }&#10;&#10;    return {S_max, false};&#10;}&#10;&#10;inline custom_bitset run_AMTS(const custom_graph&amp; g, int64_t run_time=50) {&#10;    auto max_time = std::chrono::steady_clock::now() + std::chrono::milliseconds(run_time);&#10;    // TODO: get complement for p &lt; 0.5&#10;    uint64_t Iter_Max = 100000000;&#10;    custom_bitset S_max(g.size());&#10;    custom_bitset S(g.size());&#10;    for (uint64_t k = 1; k &lt; g.size(); k++) {&#10;        if (std::chrono::steady_clock::now() &gt; max_time) break;&#10;&#10;        uint64_t L = g.size() * k;&#10;        // if brock or san L = 4 * k;&#10;        bool is_legal_k_clique = false;&#10;        std::tie(S, is_legal_k_clique) = AMTS(g, k, L, Iter_Max, max_time);&#10;        if (!is_legal_k_clique) return S_max;&#10;        S_max = S;&#10;    }&#10;    return S_max;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/BBMC.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/BBMC.h" />
              <option name="originalContent" value="//&#10;// Created by Beniamino Vagnarelli on 03/04/25.&#10;//&#10;&#10;#pragma once&#10;&#10;#include &lt;vector&gt;&#10;#include &quot;custom_graph.h&quot;&#10;&#10;// k_min can be negative! int and not uint. It causes bugs&#10;inline void BB_Color(const custom_graph&amp; g, custom_bitset Ubb, std::vector&lt;uint64_t&gt;&amp; Ul, std::vector&lt;uint64_t&gt;&amp; C, const int64_t k_min=0) {&#10;    static custom_bitset Qbb(g.size());&#10;    for (int64_t k = 0; Ubb; ++k) {&#10;        Qbb = Ubb;&#10;        auto v = Qbb.first_bit();&#10;&#10;        while (v != Qbb.size()) {&#10;            // al piu' posso togliere, quindi non serve iniziare di nuovo un'altra scansione&#10;            Qbb -= g.get_neighbor_set(v);&#10;&#10;            if (k &gt;= k_min) {&#10;                C[v] = k;&#10;                Ul.push_back(v);&#10;            }&#10;&#10;            //get next vertex&#10;            v = Qbb.next_bit();&#10;        }&#10;        Ubb -= Qbb;&#10;    }&#10;}&#10;&#10;inline void BBMC(const custom_graph&amp; g, custom_bitset&amp; Ubb, std::vector&lt;std::vector&lt;uint64_t&gt;&gt;&amp; Ul, std::vector&lt;std::vector&lt;uint64_t&gt;&gt;&amp; C, custom_bitset&amp; S, custom_bitset&amp; S_max, const uint64_t depth=0) {&#10;    while (!Ul[depth].empty()) {&#10;        const auto v = Ul[depth].back();&#10;        Ul[depth].pop_back();&#10;&#10;        Ubb.unset_bit(v);&#10;&#10;        const auto S_bits = S.n_set_bits() + 1;&#10;        const auto S_max_bits = S_max.n_set_bits();&#10;&#10;        if (S_bits + C[depth][v] &gt; S_max_bits) {&#10;            S.set_bit(v);&#10;&#10;            if (auto candidates = Ubb &amp; g.get_neighbor_set(v)) {&#10;                Ul[depth+1].clear();&#10;                const int64_t k_min = S_max_bits - S_bits;&#10;&#10;                BB_Color(g, candidates, Ul[depth+1], C[depth+1], k_min);&#10;&#10;                BBMC(g, candidates, Ul, C, S, S_max, depth+1);&#10;            } else if (S_bits &gt; S_max_bits) { // if there are no more candidates (leaf) check if we obtained a max clique&#10;                S_max = S;&#10;                //std::cout &lt;&lt; S_max.n_set_bits() &lt;&lt; std::endl;&#10;            }&#10;&#10;            S.unset_bit(v);&#10;        }&#10;    }&#10;}&#10;&#10;inline custom_bitset run_BBMC(const custom_graph &amp;g, custom_bitset Ubb) {&#10;    // initialize Ul&#10;    std::vector&lt;std::vector&lt;uint64_t&gt;&gt; Ul(g.size());&#10;&#10;    // max branching set&#10;    custom_bitset S(g.size());&#10;    custom_bitset S_max(g.size());&#10;&#10;    // coloring&#10;    std::vector C(g.size(), std::vector&lt;uint64_t&gt;(g.size()));&#10;&#10;    BB_Color(g, Ubb, Ul[0], C[0]);&#10;&#10;    BBMC(g, Ubb, Ul, C, S, S_max);&#10;&#10;    return g.convert_back_set(S_max);&#10;}&#10;&#10;inline custom_bitset run_BBMC(const custom_graph &amp;g) {&#10;    return run_BBMC(g, custom_bitset(g.size(), true));&#10;}&#10;" />
              <option name="updatedContent" value="//&#10;// Created by Beniamino Vagnarelli on 03/04/25.&#10;//&#10;&#10;#pragma once&#10;&#10;#include &lt;vector&gt;&#10;#include &quot;stateless_graph.h&quot;&#10;&#10;inline void BB_Color(const stateless_graph&amp; g, stateless_bitset Ubb, std::vector&lt;uint64_t&gt;&amp; Ul, std::vector&lt;uint64_t&gt;&amp; C, const int64_t k_min=0) {&#10;    static stateless_bitset Qbb(g.size());&#10;    for (int64_t k = 0; Ubb; ++k) {&#10;        Qbb = Ubb;&#10;        &#10;        for (BitCursor cursor = Qbb.first_bit(); &#10;             cursor.getPos() != Qbb.size(); &#10;             cursor = Qbb.next_bit(cursor)) {&#10;            auto v = cursor.getPos();&#10;            // at most we can remove vertices, so we don't need to start a new scan&#10;            Qbb -= g.get_neighbor_set(v);&#10;&#10;            if (k &gt;= k_min) {&#10;                C[v] = k;&#10;                Ul.push_back(v);&#10;            }&#10;        }&#10;        Ubb -= Qbb;&#10;    }&#10;}&#10;&#10;inline void BBMC(const stateless_graph&amp; g, stateless_bitset&amp; Ubb, std::vector&lt;std::vector&lt;uint64_t&gt;&gt;&amp; Ul, &#10;                std::vector&lt;std::vector&lt;uint64_t&gt;&gt;&amp; C, stateless_bitset&amp; S, stateless_bitset&amp; S_max, &#10;                const uint64_t depth=0) {&#10;    while (!Ul[depth].empty()) {&#10;        const auto v = Ul[depth].back();&#10;        Ul[depth].pop_back();&#10;&#10;        Ubb.unset_bit(v);&#10;&#10;        const auto S_bits = S.n_set_bits() + 1;&#10;        const auto S_max_bits = S_max.n_set_bits();&#10;&#10;        if (S_bits + C[depth][v] &gt; S_max_bits) {&#10;            S.set_bit(v);&#10;&#10;            auto candidates = Ubb &amp; g.get_neighbor_set(v);&#10;            if (candidates) {&#10;                Ul[depth+1].clear();&#10;                const int64_t k_min = S_max_bits - S_bits;&#10;&#10;                BB_Color(g, candidates, Ul[depth+1], C[depth+1], k_min);&#10;&#10;                BBMC(g, candidates, Ul, C, S, S_max, depth+1);&#10;            } else if (S_bits &gt; S_max_bits) {&#10;                S_max = S;&#10;            }&#10;&#10;            S.unset_bit(v);&#10;        }&#10;    }&#10;}&#10;&#10;inline stateless_bitset run_BBMC(const stateless_graph &amp;g, stateless_bitset Ubb) {&#10;    // initialize Ul&#10;    std::vector&lt;std::vector&lt;uint64_t&gt;&gt; Ul(g.size());&#10;&#10;    // max branching set&#10;    stateless_bitset S(g.size());&#10;    stateless_bitset S_max(g.size());&#10;&#10;    // coloring&#10;    std::vector C(g.size(), std::vector&lt;uint64_t&gt;(g.size()));&#10;&#10;    BB_Color(g, Ubb, Ul[0], C[0]);&#10;&#10;    BBMC(g, Ubb, Ul, C, S, S_max);&#10;&#10;    return g.convert_back_set(S_max);&#10;}&#10;&#10;inline stateless_bitset run_BBMC(const stateless_graph &amp;g) {&#10;    return run_BBMC(g, stateless_bitset(g.size(), true));&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/BBMCR.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/BBMCR.h" />
              <option name="originalContent" value="//&#10;// Created by Beniamino Vagnarelli on 03/04/25.&#10;//&#10;&#10;#pragma once&#10;&#10;#include &lt;vector&gt;&#10;#include &quot;custom_bitset.h&quot;&#10;#include &quot;custom_graph.h&quot;&#10;&#10;inline bool BB_ReCol(const custom_graph&amp; g, const uint64_t v, std::vector&lt;custom_bitset&gt;&amp; C_sets, const int64_t k_min) {&#10;    static custom_bitset inters(g.size());&#10;&#10;    // we use k &lt; k_min because in the last iteration we could do a single swap anyway&#10;    // it clearly doesn't enter the second for (with k2) because k1+1 == k_min -&gt; exit&#10;    for (int64_t k1 = 0; k1 &lt; k_min; ++k1) {&#10;        // c = a; c &amp;= b; is faster than assign c = (a &amp; b) !!!&#10;        // less memory copy&#10;        inters = C_sets[k1];&#10;        inters &amp;= g.get_neighbor_set(v);&#10;        const auto w = inters.first_bit();&#10;        // if the intersection between Ck1 and N(v) = 0 then we can put v in Ck1&#10;        if (w == inters.size()) { // empty set - single swap&#10;            // Ck1 = Ck1 U v&#10;            //C[v] = k1;&#10;            C_sets[k1].set_bit(v);&#10;            return true;&#10;        }&#10;        // if the intersection between |Ck1 and N(v)| = 1 then we could search another set where to put w (the only vertex adjacent to v)&#10;        if (inters.next_bit() == inters.size()) {  // |set| = 1 -&gt; double swap&#10;            for (int64_t k2 = k1+1; k2 &lt; k_min; ++k2) {&#10;                inters = C_sets[k2];&#10;                inters &amp;= g.get_neighbor_set(w);&#10;                // if the intersection between Ck2 and N(w) = 0 then we can put w in Ck2 and v in Ck1&#10;                if (!inters) {&#10;                    // Ck1 = (Ck1 \ w) U v&#10;                    //C[v] = k1;&#10;                    C_sets[k1].unset_bit(w);&#10;                    C_sets[k1].set_bit(v);&#10;                    // Ck2 = Ck2 U w&#10;                    //C[w] = k2;&#10;                    C_sets[k2].set_bit(w);&#10;                    return true;&#10;                }&#10;            }&#10;        }&#10;    }&#10;    return false;&#10;}&#10;&#10;inline void BB_ColorR(const custom_graph&amp; g, custom_bitset Ubb, std::vector&lt;uint64_t&gt;&amp; Ul, std::vector&lt;uint64_t&gt;&amp; C, const int64_t k_min=0) {&#10;    static std::vector C_sets(g.size(), custom_bitset(g.size()));&#10;&#10;    for (int64_t k = 0; Ubb;) {&#10;        C_sets[k] = Ubb;&#10;        auto v = C_sets[k].first_bit();&#10;&#10;        while (v != C_sets[k].size()) {&#10;            C_sets[k] -= g.get_neighbor_set(v);&#10;&#10;            //prefetch next vertex to check if the current one is the last&#10;            const auto next_v = C_sets[k].next_bit();&#10;&#10;            if (k &gt;= k_min) {&#10;                // if v is the last element remaining to color&#10;                if (next_v == C_sets[k].size() &amp;&amp; BB_ReCol(g, v, C_sets, k_min)) break;&#10;                C[v] = k;&#10;                Ul.push_back(v);&#10;            }&#10;&#10;            v = next_v;&#10;        }&#10;        // C_sets[k] contains every colored vertex&#10;        Ubb -= C_sets[k];&#10;&#10;        // if we recolored v (we didn't run v = next that equals C_sets[k].size()), we remove v from current set&#10;        // indeed v isn't part of current color (has been recolored)&#10;        // Cnew = Cnew \ v&#10;        if (v != C_sets[k].size()) {&#10;            C_sets[k].unset_bit(v);&#10;            // if, after the above operation, C_sets[k] remains empty, we don't increase k&#10;            if (!C_sets[k]) continue;&#10;        }&#10;        // otherwise we increase as usual&#10;        ++k;&#10;    }&#10;}&#10;&#10;inline void BBMCR(const custom_graph&amp; g, custom_bitset&amp; Ubb, std::vector&lt;std::vector&lt;uint64_t&gt;&gt;&amp; Ul, std::vector&lt;std::vector&lt;uint64_t&gt;&gt;&amp; C, custom_bitset&amp; S, custom_bitset&amp; S_max, const uint64_t depth=0) {&#10;    while (!Ul[depth].empty()) {&#10;        const auto v = Ul[depth].back();&#10;        Ul[depth].pop_back();&#10;&#10;        Ubb.unset_bit(v);&#10;&#10;        const auto S_bits = S.n_set_bits() + 1;&#10;        const auto S_max_bits = S_max.n_set_bits();&#10;&#10;        if (S_bits + C[depth][v] &gt; S_max_bits) {&#10;            S.set_bit(v);&#10;&#10;            if (auto candidates = Ubb &amp; g.get_neighbor_set(v)) {&#10;                Ul[depth+1].clear();&#10;                const int64_t k_min = S_max_bits - S_bits;&#10;&#10;                BB_ColorR(g, candidates, Ul[depth+1], C[depth+1], k_min);&#10;&#10;                BBMCR(g, candidates, Ul, C, S, S_max, depth+1);&#10;            } else if (S_bits &gt; S_max_bits) { // if there are no more candidates (leaf) check if we obtained a max clique&#10;                S_max = S;&#10;                std::cout &lt;&lt; S_max.n_set_bits() &lt;&lt; std::endl;&#10;            }&#10;&#10;            S.unset_bit(v);&#10;        }&#10;    }&#10;}&#10;&#10;inline custom_bitset run_BBMCR(const custom_graph&amp; g, custom_bitset Ubb) {&#10;    // initialize Ul&#10;    std::vector&lt;std::vector&lt;uint64_t&gt;&gt; Ul(g.size());&#10;&#10;    // max branching set&#10;    custom_bitset S(g.size());&#10;    custom_bitset S_max(g.size());&#10;&#10;    // coloring&#10;    std::vector C(g.size(), std::vector&lt;uint64_t&gt;(g.size()));&#10;&#10;    BB_ColorR(g, Ubb, Ul[0], C[0]);&#10;&#10;    BBMCR(g, Ubb, Ul, C, S, S_max);&#10;&#10;    return g.convert_back_set(S_max);&#10;}&#10;&#10;inline custom_bitset run_BBMCR(const custom_graph &amp;g) {&#10;    return run_BBMCR(g, custom_bitset(g.size(), true));&#10;}&#10;" />
              <option name="updatedContent" value="//&#10;// Created by Beniamino Vagnarelli on 03/04/25.&#10;//&#10;&#10;#pragma once&#10;&#10;#include &lt;vector&gt;&#10;#include &quot;custom_bitset.h&quot;&#10;#include &quot;custom_graph.h&quot;&#10;&#10;inline bool BB_ReCol(const custom_graph&amp; g, const uint64_t v, std::vector&lt;custom_bitset&gt;&amp; C_sets, const int64_t k_min) {&#10;    static custom_bitset inters(g.size());&#10;&#10;    // we use k &lt; k_min because in the last iteration we could do a single swap anyway&#10;    // it clearly doesn't enter the second for (with k2) because k1+1 == k_min -&gt; exit&#10;    for (int64_t k1 = 0; k1 &lt; k_min; ++k1) {&#10;        // c = a; c &amp;= b; is faster than assign c = (a &amp; b) !!!&#10;        // less memory copy&#10;        inters = C_sets[k1];&#10;        inters &amp;= g.get_neighbor_set(v);&#10;        const auto w = inters.first_bit();&#10;        // if the intersection between Ck1 and N(v) = 0 then we can put v in Ck1&#10;        if (w == inters.size()) { // empty set - single swap&#10;            // Ck1 = Ck1 U v&#10;            //C[v] = k1;&#10;            C_sets[k1].set_bit(v);&#10;            return true;&#10;        }&#10;        // if the intersection between |Ck1 and N(v)| = 1 then we could search another set where to put w (the only vertex adjacent to v)&#10;        if (inters.next_bit() == inters.size()) {  // |set| = 1 -&gt; double swap&#10;            for (int64_t k2 = k1+1; k2 &lt; k_min; ++k2) {&#10;                inters = C_sets[k2];&#10;                inters &amp;= g.get_neighbor_set(w);&#10;                // if the intersection between Ck2 and N(w) = 0 then we can put w in Ck2 and v in Ck1&#10;                if (!inters) {&#10;                    // Ck1 = (Ck1 \ w) U v&#10;                    //C[v] = k1;&#10;                    C_sets[k1].unset_bit(w);&#10;                    C_sets[k1].set_bit(v);&#10;                    // Ck2 = Ck2 U w&#10;                    //C[w] = k2;&#10;                    C_sets[k2].set_bit(w);&#10;                    return true;&#10;                }&#10;            }&#10;        }&#10;    }&#10;    return false;&#10;}&#10;&#10;inline void BB_ColorR(const custom_graph&amp; g, custom_bitset Ubb, std::vector&lt;uint64_t&gt;&amp; Ul, std::vector&lt;uint64_t&gt;&amp; C, const int64_t k_min=0) {&#10;    static std::vector C_sets(g.size(), custom_bitset(g.size()));&#10;&#10;    for (int64_t k = 0; Ubb;) {&#10;        C_sets[k] = Ubb;&#10;        auto cursor = C_sets[k].first_bit();&#10;&#10;        while (cursor.getPos() != C_sets[k].size()) {&#10;            C_sets[k] -= g.get_neighbor_set(cursor.getPos());&#10;&#10;            //prefetch next vertex to check if the current one is the last&#10;            const auto next_cursor = C_sets[k].next_bit(cursor);&#10;&#10;            if (k &gt;= k_min) {&#10;                // if v is the last element remaining to color&#10;                if (next_cursor.getPos() == C_sets[k].size() &amp;&amp; BB_ReCol(g, cursor.getPos(), C_sets, k_min)) break;&#10;                C[cursor.getPos()] = k;&#10;                Ul.push_back(cursor.getPos());&#10;            }&#10;&#10;            cursor = next_cursor;&#10;        }&#10;        // C_sets[k] contains every colored vertex&#10;        Ubb -= C_sets[k];&#10;&#10;        // if we recolored v (we didn't run v = next that equals C_sets[k].size()), we remove v from current set&#10;        // indeed v isn't part of current color (has been recolored)&#10;        // Cnew = Cnew \ v&#10;        if (cursor.getPos() != C_sets[k].size()) {&#10;            C_sets[k].unset_bit(cursor.getPos());&#10;            // if, after the above operation, C_sets[k] remains empty, we don't increase k&#10;            if (!C_sets[k]) continue;&#10;        }&#10;        // otherwise we increase as usual&#10;        ++k;&#10;    }&#10;}&#10;&#10;inline void BBMCR(const custom_graph&amp; g, custom_bitset&amp; Ubb, std::vector&lt;std::vector&lt;uint64_t&gt;&gt;&amp; Ul, std::vector&lt;std::vector&lt;uint64_t&gt;&gt;&amp; C, custom_bitset&amp; S, custom_bitset&amp; S_max, const uint64_t depth=0) {&#10;    while (!Ul[depth].empty()) {&#10;        const auto v = Ul[depth].back();&#10;        Ul[depth].pop_back();&#10;&#10;        Ubb.unset_bit(v);&#10;&#10;        const auto S_bits = S.n_set_bits() + 1;&#10;        const auto S_max_bits = S_max.n_set_bits();&#10;&#10;        if (S_bits + C[depth][v] &gt; S_max_bits) {&#10;            S.set_bit(v);&#10;&#10;            if (auto candidates = Ubb &amp; g.get_neighbor_set(v)) {&#10;                Ul[depth+1].clear();&#10;                const int64_t k_min = S_max_bits - S_bits;&#10;&#10;                BB_ColorR(g, candidates, Ul[depth+1], C[depth+1], k_min);&#10;&#10;                BBMCR(g, candidates, Ul, C, S, S_max, depth+1);&#10;            } else if (S_bits &gt; S_max_bits) { // if there are no more candidates (leaf) check if we obtained a max clique&#10;                S_max = S;&#10;                std::cout &lt;&lt; S_max.n_set_bits() &lt;&lt; std::endl;&#10;            }&#10;&#10;            S.unset_bit(v);&#10;        }&#10;    }&#10;}&#10;&#10;inline custom_bitset run_BBMCR(const custom_graph&amp; g, custom_bitset Ubb) {&#10;    // initialize Ul&#10;    std::vector&lt;std::vector&lt;uint64_t&gt;&gt; Ul(g.size());&#10;&#10;    // max branching set&#10;    custom_bitset S(g.size());&#10;    custom_bitset S_max(g.size());&#10;&#10;    // coloring&#10;    std::vector C(g.size(), std::vector&lt;uint64_t&gt;(g.size()));&#10;&#10;    BB_ColorR(g, Ubb, Ul[0], C[0]);&#10;&#10;    BBMCR(g, Ubb, Ul, C, S, S_max);&#10;&#10;    return g.convert_back_set(S_max);&#10;}&#10;&#10;inline custom_bitset run_BBMCR(const custom_graph &amp;g) {&#10;    return run_BBMCR(g, custom_bitset(g.size(), true));&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/CliSAT.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/CliSAT.h" />
              <option name="originalContent" value="//&#10;// Created by Beniamino Vagnarelli on 08/04/25.&#10;//&#10;&#10;#pragma once&#10;&#10;#include &lt;vector&gt;&#10;&#10;#include &quot;AMTS.h&quot;&#10;#include &quot;custom_bitset.h&quot;&#10;#include &quot;custom_graph.h&quot;&#10;#include &quot;sorting.h&quot;&#10;&#10;&#10;// TODO: implement&#10;inline void SATCOL() {&#10;&#10;}&#10;&#10;// TODO: implement&#10;inline void FiltCOL() {&#10;&#10;}&#10;&#10;// TODO: implement&#10;inline void FiltSAL() {&#10;&#10;}&#10;&#10;inline custom_bitset ISEQ_pruned(const custom_graph&amp; g, custom_bitset Ubb, const uint64_t k_max) {&#10;    custom_bitset pruned(g.size());&#10;    custom_bitset Qbb(Ubb.size());&#10;    uint64_t k = 0;&#10;    for (k = 0; k &lt; k_max; ++k) {&#10;        Qbb = Ubb;&#10;        for (BitCursor cursor = Qbb.first_bit();&#10;             cursor.block_index != Qbb.bits.size();&#10;             cursor = Qbb.next_bit(cursor)) {&#10;            // at most we can remove vertices, so we don't need to start a new scan&#10;            Qbb -= g.get_neighbor_set(cursor.getPos());&#10;        }&#10;        // add vertices to pruned&#10;        pruned |= Qbb;&#10;        Ubb -= Qbb;&#10;    }&#10;    return pruned;&#10;}&#10;&#10;inline bool UnitPropagation(&#10;    const custom_graph&amp; G,&#10;    const custom_bitset&amp; Pc,    // pruned set that satisfy the condition: |K|+UP(Pc) &lt;= lb (the greatest clique of K union P can't be greater than the lower bound)&#10;    const custom_bitset&amp; B      // branching sets used to enlarge the pruned set&#10;) {&#10;    return false;&#10;    //ISEQ_sets&#10;}&#10;&#10;&#10;// Page 8 (143) Li et al. (2018a, 2017), section 5.2.1&#10;// return a set B of branching vertices&#10;inline custom_bitset FilterByColiring(&#10;    const custom_graph&amp; G,      // Ordered graph&#10;    custom_bitset&amp; P,          // Candidate set {p1, p2, ..., p|P|}&#10;    const uint64_t r          // lower bound (largest clique found so far)&#10;) {&#10;    custom_bitset B(P.size());  // B, a set of branching vertices obtained from P&#10;    std::vector&lt;custom_bitset&gt; IS;  // set of independent sets&#10;&#10;    for (BitCursor cursor = P.last_bit_destructive();&#10;         cursor.block_index != P.bits.size();&#10;         cursor = P.next_bit_destructive(cursor)) {&#10;        // Implementation goes here&#10;    }&#10;    return B;&#10;}&#10;&#10;// TODO: P pass by reference or not? I don't think so&#10;// we pass u by copy, not reference!&#10;inline void FindMaxClique(&#10;    const custom_graph&amp; G,  // graph&#10;    custom_bitset&amp; K,       // current branch&#10;    custom_bitset&amp; K_max,   // max branch&#10;    uint64_t&amp; lb,           // lower bound&#10;    const custom_bitset&amp; V, // vertices set&#10;    custom_bitset &amp;P,       // pruned set&#10;    custom_bitset &amp;B,       // branching set&#10;    std::vector&lt;uint64_t&gt; u // incremental upper bounds&#10;) {&#10;    for (BitCursor cursor = B.first_bit();&#10;         cursor.block_index != B.bits.size();&#10;         cursor = B.next_bit(cursor)) {&#10;        auto bi = cursor.getPos();&#10;&#10;        // calculate u[bi]&#10;        // if bi == 0, u[bi] always == 1!&#10;        custom_bitset preced_neighb_set(bi, true);&#10;        preced_neighb_set &amp;= G.get_neighbor_set(bi, V);&#10;&#10;        uint64_t max_u = 0;&#10;        for (BitCursor neighb_cursor = preced_neighb_set.first_bit();&#10;             neighb_cursor.block_index != preced_neighb_set.bits.size();&#10;             neighb_cursor = preced_neighb_set.next_bit(neighb_cursor)) {&#10;            max_u = std::max(max_u, u[neighb_cursor.getPos()]);&#10;        }&#10;        u[bi] = 1 + max_u;&#10;&#10;&#10;        if (u[bi] + K.n_set_bits() &lt;= lb) {&#10;            P.set_bit(bi);&#10;            B.unset_bit(bi);&#10;        } else {&#10;            K.set_bit(bi);&#10;            auto V_new = (P &amp; G.get_neighbor_set(bi)) | (B &amp; preced_neighb_set);&#10;&#10;            if (!V_new) {&#10;                if (K.n_set_bits() &gt; lb) {&#10;                    lb = K.n_set_bits();&#10;                    K_max = K;&#10;                    std::cout &lt;&lt; lb &lt;&lt; std::endl;&#10;                }&#10;                K.unset_bit(bi);&#10;                // TODO: continue or return?&#10;                return;&#10;            }&#10;            auto P_new = ISEQ_pruned(G, V_new, lb-K.n_set_bits());&#10;            auto B_new = V_new - P_new;&#10;&#10;            // TODO&#10;            // PMAX-SAT-P-based upper bounds&#10;            // FiltCOL&#10;            // FiltSAT&#10;            // SATCOL&#10;&#10;            if (B_new) {&#10;                FindMaxClique(G, K, K_max, lb, V_new, P_new, B_new, u);&#10;            }&#10;            K.unset_bit(bi);&#10;        }&#10;        // TODO: here or above?&#10;&#10;        u[bi] = std::min(u[bi], lb - K.n_set_bits());&#10;    }&#10;}&#10;&#10;inline custom_bitset CliSAT(const custom_graph&amp; g) {&#10;    auto [ordering, k] = NEW_SORT(g);&#10;    auto ordered_g = g.change_order(ordering);&#10;&#10;    auto K_max = run_AMTS(ordered_g); // lb &lt;- |K|    -&gt;     ANTS Tabu search&#10;    uint64_t lb = K_max.n_set_bits();&#10;&#10;    std::vector&lt;uint64_t&gt; u(ordered_g.size());&#10;    // first |k_max| values bounded by |K_max| (==lb)&#10;    u[0] = 1;&#10;    for (uint64_t i = 1; i &lt; lb; i++) {&#10;        uint64_t max_u = 0;&#10;        custom_bitset preced_neighb_set(i, true);&#10;        preced_neighb_set &amp;= ordered_g.get_neighbor_set(i);&#10;&#10;        for (BitCursor cursor = preced_neighb_set.first_bit();&#10;             cursor.block_index != preced_neighb_set.bits.size();&#10;             cursor = preced_neighb_set.next_bit(cursor)) {&#10;            max_u = std::max(max_u, u[cursor.getPos()]);&#10;        }&#10;        u[i] = std::min(1 + max_u, lb);&#10;    }&#10;    // remaining values bounded by k&#10;    for (uint64_t i = lb; i &lt; ordered_g.size(); i++) {&#10;        uint64_t max_u = 0;&#10;        custom_bitset preced_neighb_set(i, true);&#10;        preced_neighb_set &amp;= ordered_g.get_neighbor_set(i);&#10;&#10;        for (BitCursor cursor = preced_neighb_set.first_bit();&#10;             cursor.block_index != preced_neighb_set.bits.size();&#10;             cursor = preced_neighb_set.next_bit(cursor)) {&#10;            max_u = std::max(max_u, u[cursor.getPos()]);&#10;        }&#10;        u[i] = std::min(1 + max_u, k);&#10;    }&#10;&#10;    for (uint64_t i = K_max.n_set_bits(); i &lt; ordered_g.size(); ++i) {&#10;        std::cout &lt;&lt; &quot;i: &quot; &lt;&lt; i &lt;&lt; std::endl;&#10;        custom_bitset V(i, true);&#10;        V &amp;= ordered_g.get_neighbor_set(i);&#10;&#10;        // first lb vertices of V&#10;        custom_bitset P(ordered_g.size());&#10;        uint64_t count = 0;&#10;        for (BitCursor cursor = V.first_bit();&#10;             cursor.block_index != V.bits.size() &amp;&amp; count &lt; lb;&#10;             cursor = V.next_bit(cursor)) {&#10;            P.set_bit(cursor.getPos());&#10;            count++;&#10;        }&#10;&#10;        auto B = V - P;&#10;&#10;        custom_bitset K(ordered_g.size());&#10;        K.set_bit(i);&#10;&#10;        FindMaxClique(ordered_g, K, K_max, lb, V, P, B, u);&#10;        u[i] = lb;&#10;    }&#10;&#10;    return ordered_g.convert_back_set(K_max);&#10;}&#10;" />
              <option name="updatedContent" value="//&#10;// Created by Beniamino Vagnarelli on 08/04/25.&#10;//&#10;&#10;#pragma once&#10;&#10;#include &lt;vector&gt;&#10;&#10;#include &quot;AMTS.h&quot;&#10;#include &quot;custom_bitset.h&quot;&#10;#include &quot;custom_graph.h&quot;&#10;#include &quot;sorting.h&quot;&#10;&#10;&#10;// TODO: implement&#10;inline void SATCOL() {&#10;&#10;}&#10;&#10;// TODO: implement&#10;inline void FiltCOL() {&#10;&#10;}&#10;&#10;// TODO: implement&#10;inline void FiltSAL() {&#10;&#10;}&#10;&#10;inline custom_bitset ISEQ_pruned(const custom_graph&amp; g, custom_bitset Ubb, const uint64_t k_max) {&#10;    custom_bitset pruned(g.size());&#10;    custom_bitset Qbb(Ubb.size());&#10;    uint64_t k = 0;&#10;    for (k = 0; k &lt; k_max; ++k) {&#10;        Qbb = Ubb;&#10;        for (BitCursor cursor = Qbb.first_bit(); &#10;             cursor.getPos() != Qbb.size(); &#10;             cursor = Qbb.next_bit(cursor)) {&#10;            // at most we can remove vertices, so we don't need to start a new scan&#10;            Qbb -= g.get_neighbor_set(cursor.getPos());&#10;        }&#10;        // add vertices to pruned&#10;        pruned |= Qbb;&#10;        Ubb -= Qbb;&#10;    }&#10;    return pruned;&#10;}&#10;&#10;inline bool UnitPropagation(&#10;    const custom_graph&amp; G,&#10;    const custom_bitset&amp; Pc,    // pruned set that satisfy the condition: |K|+UP(Pc) &lt;= lb (the greatest clique of K union P can't be greater than the lower bound)&#10;    const custom_bitset&amp; B      // branching sets used to enlarge the pruned set&#10;) {&#10;    return false;&#10;    //ISEQ_sets&#10;}&#10;&#10;&#10;// Page 8 (143) Li et al. (2018a, 2017), section 5.2.1&#10;// return a set B of branching vertices&#10;inline custom_bitset FilterByColiring(&#10;    const custom_graph&amp; G,      // Ordered graph&#10;    custom_bitset&amp; P,          // Candidate set {p1, p2, ..., p|P|}&#10;    const uint64_t r          // lower bound (largest clique found so far)&#10;) {&#10;    custom_bitset B(P.size());  // B, a set of branching vertices obtained from P&#10;    std::vector&lt;custom_bitset&gt; IS;  // set of independent sets&#10;&#10;    for (BitCursor cursor = P.last_bit_destructive();&#10;         cursor.block_index != P.bits.size();&#10;         cursor = P.next_bit_destructive(cursor)) {&#10;        // Implementation goes here&#10;    }&#10;    return B;&#10;}&#10;&#10;// TODO: P pass by reference or not? I don't think so&#10;// we pass u by copy, not reference!&#10;inline void FindMaxClique(&#10;    const custom_graph&amp; G,  // graph&#10;    custom_bitset&amp; K,       // current branch&#10;    custom_bitset&amp; K_max,   // max branch&#10;    uint64_t&amp; lb,           // lower bound&#10;    const custom_bitset&amp; V, // vertices set&#10;    custom_bitset &amp;P,       // pruned set&#10;    custom_bitset &amp;B,       // branching set&#10;    std::vector&lt;uint64_t&gt; u // incremental upper bounds&#10;) {&#10;    for (BitCursor cursor = B.first_bit(); &#10;         cursor.getPos() != B.size(); &#10;         cursor = B.next_bit(cursor)) {&#10;        auto bi = cursor.getPos();&#10;&#10;        // calculate u[bi]&#10;        // if bi == 0, u[bi] always == 1!&#10;        custom_bitset preced_neighb_set(bi, true);&#10;        preced_neighb_set &amp;= G.get_neighbor_set(bi, V);&#10;&#10;        uint64_t max_u = 0;&#10;        for (BitCursor neighb_cursor = preced_neighb_set.first_bit(); &#10;             neighb_cursor.getPos() != preced_neighb_set.size(); &#10;             neighb_cursor = preced_neighb_set.next_bit(neighb_cursor)) {&#10;            max_u = std::max(max_u, u[neighb_cursor.getPos()]);&#10;        }&#10;        u[bi] = 1 + max_u;&#10;&#10;&#10;        if (u[bi] + K.n_set_bits() &lt;= lb) {&#10;            P.set_bit(bi);&#10;            B.unset_bit(bi);&#10;        } else {&#10;            K.set_bit(bi);&#10;            auto V_new = (P &amp; G.get_neighbor_set(bi)) | (B &amp; preced_neighb_set);&#10;&#10;            if (!V_new) {&#10;                if (K.n_set_bits() &gt; lb) {&#10;                    lb = K.n_set_bits();&#10;                    K_max = K;&#10;                    std::cout &lt;&lt; lb &lt;&lt; std::endl;&#10;                }&#10;                K.unset_bit(bi);&#10;                // TODO: continue or return?&#10;                return;&#10;            }&#10;            auto P_new = ISEQ_pruned(G, V_new, lb-K.n_set_bits());&#10;            auto B_new = V_new - P_new;&#10;&#10;            // TODO&#10;            // PMAX-SAT-P-based upper bounds&#10;            // FiltCOL&#10;            // FiltSAT&#10;            // SATCOL&#10;&#10;            if (B_new) {&#10;                FindMaxClique(G, K, K_max, lb, V_new, P_new, B_new, u);&#10;            }&#10;            K.unset_bit(bi);&#10;        }&#10;        // TODO: here or above?&#10;&#10;        u[bi] = std::min(u[bi], lb - K.n_set_bits());&#10;    }&#10;}&#10;&#10;inline custom_bitset CliSAT(const custom_graph&amp; g) {&#10;    auto [ordering, k] = NEW_SORT(g);&#10;    auto ordered_g = g.change_order(ordering);&#10;&#10;    auto K_max = run_AMTS(ordered_g); // lb &lt;- |K|    -&gt;     ANTS Tabu search&#10;    uint64_t lb = K_max.n_set_bits();&#10;&#10;    std::vector&lt;uint64_t&gt; u(ordered_g.size());&#10;    // first |k_max| values bounded by |K_max| (==lb)&#10;    u[0] = 1;&#10;    for (uint64_t i = 1; i &lt; lb; i++) {&#10;        uint64_t max_u = 0;&#10;        custom_bitset preced_neighb_set(i, true);&#10;        preced_neighb_set &amp;= ordered_g.get_neighbor_set(i);&#10;&#10;        for (BitCursor cursor = preced_neighb_set.first_bit(); &#10;             cursor.getPos() != preced_neighb_set.size(); &#10;             cursor = preced_neighb_set.next_bit(cursor)) {&#10;            max_u = std::max(max_u, u[cursor.getPos()]);&#10;        }&#10;        u[i] = std::min(1 + max_u, lb);&#10;    }&#10;&#10;    // remaining values bounded by k&#10;    for (uint64_t i = lb; i &lt; ordered_g.size(); i++) {&#10;        uint64_t max_u = 0;&#10;        custom_bitset preced_neighb_set(i, true);&#10;        preced_neighb_set &amp;= ordered_g.get_neighbor_set(i);&#10;&#10;        for (BitCursor cursor = preced_neighb_set.first_bit(); &#10;             cursor.getPos() != preced_neighb_set.size(); &#10;             cursor = preced_neighb_set.next_bit(cursor)) {&#10;            max_u = std::max(max_u, u[cursor.getPos()]);&#10;        }&#10;        u[i] = std::min(1 + max_u, k);&#10;    }&#10;&#10;    for (uint64_t i = K_max.n_set_bits(); i &lt; ordered_g.size(); ++i) {&#10;        std::cout &lt;&lt; &quot;i: &quot; &lt;&lt; i &lt;&lt; std::endl;&#10;        custom_bitset V(i, true);&#10;        V &amp;= ordered_g.get_neighbor_set(i);&#10;&#10;        // first lb vertices of V&#10;        custom_bitset P(ordered_g.size());&#10;        uint64_t count = 0;&#10;        for (BitCursor cursor = V.first_bit();&#10;             cursor.getPos() != V.size() &amp;&amp; count &lt; lb;&#10;             cursor = V.next_bit(cursor)) {&#10;            P.set_bit(cursor.getPos());&#10;            count++;&#10;        }&#10;&#10;        auto B = V - P;&#10;&#10;        custom_bitset K(ordered_g.size());&#10;        K.set_bit(i);&#10;&#10;        FindMaxClique(ordered_g, K, K_max, lb, V, P, B, u);&#10;        u[i] = lb;&#10;    }&#10;&#10;    return ordered_g.convert_back_set(K_max);&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/bitscan_benchmark.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/bitscan_benchmark.h" />
              <option name="originalContent" value="//&#10;// Created by Beniamino Vagnarelli on 31/03/25.&#10;//&#10;&#10;#pragma once&#10;&#10;#include &lt;iostream&gt;&#10;#include &lt;chrono&gt;&#10;#include &lt;vector&gt;&#10;#include &lt;immintrin.h&gt;&#10;#include &lt;algorithm&gt;&#10;#include &lt;bitscan/bitscan.h&gt;&#10;#include &lt;graph/graph.h&gt;&#10;#include &quot;custom_bitset.h&quot;&#10;&#10;uint64_t randll() {&#10;    return (static_cast&lt;uint64_t&gt;(std::rand()) &lt;&lt; 32) | std::rand();&#10;}&#10;&#10;void bitscan_benchmark1() {&#10;    std::srand(static_cast&lt;unsigned&gt;(std::time(nullptr)));&#10;&#10;    std::chrono::steady_clock::time_point begin = std::chrono::steady_clock::now();&#10;    std::chrono::steady_clock::time_point end = std::chrono::steady_clock::now();&#10;&#10;    std::vector&lt;uint64_t&gt; numbers(50000000);&#10;    std::ranges::generate(numbers, randll);&#10;&#10;&#10;    std::cout &lt;&lt; &quot;Bit Scan Forward:&quot; &lt;&lt; std::endl;&#10;    uint64_t a = 0;&#10;&#10;    begin = std::chrono::steady_clock::now();&#10;    for (auto number : numbers) {&#10;        a += __builtin_ctzll(number);&#10;    }&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;__builtin_ctzll = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;&#10;    begin = std::chrono::steady_clock::now();&#10;    for (auto number : numbers) {&#10;        a += __bsfq(number);&#10;    }&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;__bsfq = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;&#10;    // up to 32 bits integers&#10;    /*&#10;    begin = std::chrono::steady_clock::now();&#10;    for (auto number : numbers) {&#10;        a += _bit_scan_forward(number);&#10;    }&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;_bit_scan_forward = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;    */&#10;&#10;    begin = std::chrono::steady_clock::now();&#10;    for (auto number : numbers) {&#10;        unsigned long long  Ret;&#10;        __asm__&#10;        (&#10;            &quot;bsfq %[number], %[Ret]&quot;&#10;            :[Ret] &quot;=r&quot; (Ret)&#10;            :[number] &quot;mr&quot; (number)&#10;        );&#10;        a += Ret;&#10;    }&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;asm bsfq = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;&#10;    begin = std::chrono::steady_clock::now();&#10;    for (auto number : numbers) {&#10;        a += std::countr_zero(number);&#10;    }&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;std::countr_zero = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;&#10;    std::cout &lt;&lt; std::endl;&#10;&#10;&#10;    std::cout &lt;&lt; &quot;Bit Scan Reverse&quot; &lt;&lt; std::endl;&#10;&#10;    begin = std::chrono::steady_clock::now();&#10;    for (auto number : numbers) {&#10;        a += 63 - __builtin_clzll(number);&#10;    }&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;63 - _builtin_clzll = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;&#10;    begin = std::chrono::steady_clock::now();&#10;    for (auto number : numbers) {&#10;        a += __bsrq(number);&#10;    }&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;__bsrq = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;&#10;    begin = std::chrono::steady_clock::now();&#10;    for (auto number : numbers) {&#10;        a += __builtin_ia32_bsrdi(number);&#10;    }&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;__builtin_ia32_bsrdi = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;&#10;    // up to 32 bits integers&#10;    /*&#10;    begin = std::chrono::steady_clock::now();&#10;    for (auto number : numbers) {&#10;        a += _bit_scan_reverse(number);&#10;    }&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;_bit_scan_reverse = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;    */&#10;&#10;    begin = std::chrono::steady_clock::now();&#10;    for (auto number : numbers) {&#10;         unsigned long long Ret;&#10;        __asm__&#10;        (&#10;            &quot;bsrq %[number], %[Ret]&quot;&#10;            :[Ret] &quot;=r&quot; (Ret)&#10;            :[number] &quot;mr&quot; (number)&#10;        );&#10;        a += Ret;&#10;    }&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;asm bsrq = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;&#10;    begin = std::chrono::steady_clock::now();&#10;    for (auto number : numbers) {&#10;        a += std::bit_floor(number);&#10;    }&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;std::bit_floor = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;&#10;    begin = std::chrono::steady_clock::now();&#10;    for (auto number : numbers) {&#10;        a += std::bit_width(number) - 1;&#10;    }&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;std::bit_width = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;&#10;    begin = std::chrono::steady_clock::now();&#10;    for (auto number : numbers) {&#10;        a += 63 - std::countl_zero(number);&#10;    }&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;std::countl_zero = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;&#10;    std::cout &lt;&lt; a &lt;&lt; std::endl;&#10;}&#10;&#10;&#10;void popcount_benchmark() {&#10;    std::srand(static_cast&lt;unsigned&gt;(std::time(nullptr)));&#10;&#10;    std::chrono::steady_clock::time_point begin = std::chrono::steady_clock::now();&#10;    std::chrono::steady_clock::time_point end = std::chrono::steady_clock::now();&#10;&#10;    std::vector&lt;uint64_t&gt; numbers(500000000);&#10;    std::ranges::generate(numbers, randll);&#10;&#10;&#10;    std::cout &lt;&lt; &quot;PopCount:&quot; &lt;&lt; std::endl;&#10;    uint64_t a = 0;&#10;&#10;    begin = std::chrono::steady_clock::now();&#10;    for (auto number : numbers) {&#10;        a += std::popcount(number);&#10;    }&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;std::popcount = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;&#10;    begin = std::chrono::steady_clock::now();&#10;    for (auto number : numbers) {&#10;        a += __popcount(number);&#10;    }&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;__popcount = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;&#10;    begin = std::chrono::steady_clock::now();&#10;    for (auto number : numbers) {&#10;        a += __builtin_popcountll(number);&#10;    }&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;__builtin_popcountll = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;&#10;    std::cout &lt;&lt; a &lt;&lt; std::endl;&#10;}&#10;&#10;void bit_scan_forward_benchmark() {&#10;    std::cout &lt;&lt; &quot;Benchmark bit scan forward&quot; &lt;&lt; std::endl;&#10;    std::srand(static_cast&lt;unsigned&gt;(std::time(nullptr)));&#10;&#10;    std::chrono::steady_clock::time_point begin;&#10;    std::chrono::steady_clock::time_point end;&#10;&#10;    uint64_t len = 50000000;&#10;    uint64_t acc = 0;&#10;    uint64_t bit = 0;&#10;&#10;    bitarray bb_empty(len);&#10;    bitarray bb_random(len);&#10;    bitarray bb_complete(len);&#10;    custom_bitset c_bb_empty(len);&#10;    custom_bitset c_bb_random(len);&#10;    custom_bitset c_bb_complete(len);&#10;    stateless_bitset s_bb_empty(len);&#10;    stateless_bitset s_bb_random(len);&#10;    stateless_bitset s_bb_complete(len);&#10;&#10;    for (uint64_t i = 0; i &lt; len; i++) {&#10;        if (rand() % 2) {&#10;            bb_random.set_bit(i);&#10;            c_bb_random.set_bit(i);&#10;            s_bb_random.set_bit(i);&#10;        }&#10;        bb_complete.set_bit(i);&#10;        c_bb_complete.set_bit(i);&#10;        s_bb_complete.set_bit(i);&#10;    }&#10;    bb_empty.init_scan(bbo::NON_DESTRUCTIVE);&#10;    bb_random.init_scan(bbo::NON_DESTRUCTIVE);&#10;    bb_complete.init_scan(bbo::NON_DESTRUCTIVE);&#10;&#10;    begin = std::chrono::steady_clock::now();&#10;    while(bb_empty.next_bit() != BBObject::noBit) { ++acc; }&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;bit scan empty = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;&#10;    begin = std::chrono::steady_clock::now();&#10;    bit = c_bb_empty.first_bit();&#10;    while(bit != c_bb_empty.size()) { bit = c_bb_empty.next_bit(); ++acc; }&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;custom bitset empty = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;&#10;    begin = std::chrono::steady_clock::now();&#10;    for (BitCursor cursor = s_bb_empty.first_bit();&#10;         cursor.block_index != s_bb_empty.bits.size();&#10;         cursor = s_bb_empty.next_bit(cursor)) {&#10;        ++acc;&#10;    }&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;stateless bitset empty = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;&#10;    begin = std::chrono::steady_clock::now();&#10;    while(bb_random.next_bit() != BBObject::noBit) { ++acc; }&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;bit scan random = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;&#10;    begin = std::chrono::steady_clock::now();&#10;    bit = c_bb_random.first_bit();&#10;    while(bit != c_bb_random.size()) { bit = c_bb_random.next_bit(); ++acc; }&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;custom bitset random = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;&#10;    begin = std::chrono::steady_clock::now();&#10;    for (BitCursor cursor = s_bb_random.first_bit();&#10;         cursor.block_index != s_bb_random.bits.size();&#10;         cursor = s_bb_random.next_bit(cursor)) {&#10;        ++acc;&#10;    }&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;stateless bitset random = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;&#10;    begin = std::chrono::steady_clock::now();&#10;    while(bb_complete.next_bit() != BBObject::noBit) { ++acc; }&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;bit scan complete = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;&#10;    begin = std::chrono::steady_clock::now();&#10;    bit = c_bb_complete.first_bit();&#10;    while(bit != c_bb_complete.size()) { bit = c_bb_complete.next_bit(); ++acc; }&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;custom bitset complete = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;&#10;    begin = std::chrono::steady_clock::now();&#10;    for (BitCursor cursor = s_bb_complete.first_bit();&#10;         cursor.block_index != s_bb_complete.bits.size();&#10;         cursor = s_bb_complete.next_bit(cursor)) {&#10;        ++acc;&#10;    }&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;stateless bitset complete = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;&#10;    std::cout &lt;&lt; &quot;Total bits scanned: &quot; &lt;&lt; acc &lt;&lt; std::endl;&#10;}&#10;&#10;void bit_scan_forward_destructive_benchmark() {&#10;    std::cout &lt;&lt; &quot;Benchmark bit scan forward destructive&quot; &lt;&lt; std::endl;&#10;    std::srand(static_cast&lt;unsigned&gt;(std::time(nullptr)));&#10;&#10;    std::chrono::steady_clock::time_point begin;&#10;    std::chrono::steady_clock::time_point end;&#10;&#10;    uint64_t len = 50000000;&#10;    uint64_t acc = 0;&#10;    uint64_t bit = 0;&#10;&#10;    bitarray bb_empty(len);&#10;    bitarray bb_random(len);&#10;    bitarray bb_complete(len);&#10;    custom_bitset c_bb_empty(len);&#10;    custom_bitset c_bb_random(len);&#10;    custom_bitset c_bb_complete(len);&#10;    stateless_bitset s_bb_empty(len);&#10;    stateless_bitset s_bb_random(len);&#10;    stateless_bitset s_bb_complete(len);&#10;&#10;    for (uint64_t i = 0; i &lt; len; i++) {&#10;        if (rand() % 2) {&#10;            bb_random.set_bit(i);&#10;            c_bb_random.set_bit(i);&#10;            s_bb_random.set_bit(i);&#10;        }&#10;        bb_complete.set_bit(i);&#10;        c_bb_complete.set_bit(i);&#10;        s_bb_complete.set_bit(i);&#10;    }&#10;    bb_empty.init_scan(bbo::DESTRUCTIVE);&#10;    bb_random.init_scan(bbo::DESTRUCTIVE);&#10;    bb_complete.init_scan(bbo::DESTRUCTIVE);&#10;&#10;    begin = std::chrono::steady_clock::now();&#10;    while(bb_empty.next_bit() != BBObject::noBit) { ++acc; }&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;bit scan empty = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;&#10;    begin = std::chrono::steady_clock::now();&#10;    bit = c_bb_empty.first_bit_destructive();&#10;    while(bit != c_bb_empty.size()) { bit = c_bb_empty.next_bit_destructive(); ++acc; }&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;custom bitset empty = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;&#10;    begin = std::chrono::steady_clock::now();&#10;    for (BitCursor cursor = s_bb_empty.first_bit_destructive();&#10;         cursor.block_index != s_bb_empty.bits.size();&#10;         cursor = s_bb_empty.next_bit_destructive(cursor)) {&#10;        ++acc;&#10;    }&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;stateless bitset empty = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;&#10;    begin = std::chrono::steady_clock::now();&#10;    while(bb_random.next_bit() != BBObject::noBit) { ++acc; }&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;bit scan random = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;&#10;    begin = std::chrono::steady_clock::now();&#10;    bit = c_bb_random.first_bit_destructive();&#10;    while(bit != c_bb_random.size()) { bit = c_bb_random.next_bit_destructive(); ++acc; }&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;custom bitset random = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;&#10;    begin = std::chrono::steady_clock::now();&#10;    for (BitCursor cursor = s_bb_random.first_bit_destructive();&#10;         cursor.block_index != s_bb_random.bits.size();&#10;         cursor = s_bb_random.next_bit_destructive(cursor)) {&#10;        ++acc;&#10;    }&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;stateless bitset random = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;&#10;    begin = std::chrono::steady_clock::now();&#10;    while(bb_complete.next_bit() != BBObject::noBit) { ++acc; }&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;bit scan complete = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;&#10;    begin = std::chrono::steady_clock::now();&#10;    bit = c_bb_complete.first_bit_destructive();&#10;    while(bit != c_bb_complete.size()) { bit = c_bb_complete.next_bit_destructive(); ++acc; }&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;custom bitset complete = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;&#10;    begin = std::chrono::steady_clock::now();&#10;    for (BitCursor cursor = s_bb_complete.first_bit_destructive();&#10;         cursor.block_index != s_bb_complete.bits.size();&#10;         cursor = s_bb_complete.next_bit_destructive(cursor)) {&#10;        ++acc;&#10;    }&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;stateless bitset complete = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;&#10;    std::cout &lt;&lt; &quot;Total bits scanned: &quot; &lt;&lt; acc &lt;&lt; std::endl;&#10;}&#10;&#10;void bit_scan_reverse_benchmark() {&#10;    std::cout &lt;&lt; &quot;Benchmark bit scan reverse&quot; &lt;&lt; std::endl;&#10;    std::srand(static_cast&lt;unsigned&gt;(std::time(nullptr)));&#10;&#10;    std::chrono::steady_clock::time_point begin;&#10;    std::chrono::steady_clock::time_point end;&#10;&#10;    uint64_t len = 50000000;&#10;    uint64_t acc = 0;&#10;    uint64_t bit = 0;&#10;&#10;    bitarray bb_empty(len);&#10;    bitarray bb_random(len);&#10;    bitarray bb_complete(len);&#10;    custom_bitset c_bb_empty(len);&#10;    custom_bitset c_bb_random(len);&#10;    custom_bitset c_bb_complete(len);&#10;    stateless_bitset s_bb_empty(len);&#10;    stateless_bitset s_bb_random(len);&#10;    stateless_bitset s_bb_complete(len);&#10;&#10;    for (uint64_t i = 0; i &lt; len; i++) {&#10;        if (rand() % 2) {&#10;            bb_random.set_bit(i);&#10;            c_bb_random.set_bit(i);&#10;            s_bb_random.set_bit(i);&#10;        }&#10;        bb_complete.set_bit(i);&#10;        c_bb_complete.set_bit(i);&#10;        s_bb_complete.set_bit(i);&#10;    }&#10;    bb_empty.init_scan(bbo::NON_DESTRUCTIVE_REVERSE);&#10;    bb_random.init_scan(bbo::NON_DESTRUCTIVE_REVERSE);&#10;    bb_complete.init_scan(bbo::NON_DESTRUCTIVE_REVERSE);&#10;&#10;    begin = std::chrono::steady_clock::now();&#10;    while(bb_empty.prev_bit() != BBObject::noBit) { ++acc; }&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;bit scan empty = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;&#10;    begin = std::chrono::steady_clock::now();&#10;    bit = c_bb_empty.last_bit();&#10;    while(bit != c_bb_empty.size()) { bit = c_bb_empty.prev_bit(); ++acc; }&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;custom bitset empty = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;&#10;    begin = std::chrono::steady_clock::now();&#10;    for (BitCursor cursor = s_bb_empty.last_bit();&#10;         cursor.block_index != s_bb_empty.bits.size();&#10;         cursor = s_bb_empty.prev_bit(cursor)) {&#10;        ++acc;&#10;    }&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;stateless bitset empty = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;&#10;    begin = std::chrono::steady_clock::now();&#10;    while(bb_random.prev_bit() != BBObject::noBit) { ++acc; }&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;bit scan random = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;&#10;    begin = std::chrono::steady_clock::now();&#10;    bit = c_bb_random.last_bit();&#10;    while(bit != c_bb_random.size()) { bit = c_bb_random.prev_bit(); ++acc; }&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;custom bitset random = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;&#10;    begin = std::chrono::steady_clock::now();&#10;    for (BitCursor cursor = s_bb_random.last_bit();&#10;         cursor.block_index != s_bb_random.bits.size();&#10;         cursor = s_bb_random.prev_bit(cursor)) {&#10;        ++acc;&#10;    }&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;stateless bitset random = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;&#10;    begin = std::chrono::steady_clock::now();&#10;    while(bb_complete.prev_bit() != BBObject::noBit) { ++acc; }&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;bit scan complete = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;&#10;    begin = std::chrono::steady_clock::now();&#10;    bit = c_bb_complete.last_bit();&#10;    while(bit != c_bb_complete.size()) { bit = c_bb_complete.prev_bit(); ++acc; }&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;custom bitset complete = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;&#10;    begin = std::chrono::steady_clock::now();&#10;    for (BitCursor cursor = s_bb_complete.last_bit();&#10;         cursor.block_index != s_bb_complete.bits.size();&#10;         cursor = s_bb_complete.prev_bit(cursor)) {&#10;        ++acc;&#10;    }&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;stateless bitset complete = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;&#10;    std::cout &lt;&lt; &quot;Total bits scanned: &quot; &lt;&lt; acc &lt;&lt; std::endl;&#10;}&#10;&#10;&#10;void bitwise_and_benchmark() {&#10;    std::cout &lt;&lt; &quot;Benchmark bitwise and&quot; &lt;&lt; std::endl;&#10;    std::srand(static_cast&lt;unsigned&gt;(std::time(nullptr)));&#10;&#10;    std::chrono::steady_clock::time_point begin = std::chrono::steady_clock::now();&#10;    std::chrono::steady_clock::time_point end = std::chrono::steady_clock::now();&#10;&#10;    uint64_t len = 500000000;&#10;&#10;    uint64_t acc = 0;&#10;&#10;    bitarray bbi1(len);&#10;    bitarray bbi2(len);&#10;    custom_bitset bb31(len);&#10;    custom_bitset bb32(len);&#10;    for (uint64_t i = 0; i &lt; len; i++) {&#10;        if (rand() % 2) {&#10;            bbi1.set_bit(i);&#10;            bb31.set_bit(i);&#10;        }&#10;    }&#10;    for (uint64_t i = 0; i &lt; len; i++) {&#10;        if (rand() % 2) {&#10;            bbi2.set_bit(i);&#10;            bb32.set_bit(i);&#10;        }&#10;    }&#10;    // std::cout &lt;&lt; bbi;&#10;&#10;    begin = std::chrono::steady_clock::now();&#10;    bbi1 &amp;= bbi2;&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;bit scan = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;&#10;    begin = std::chrono::steady_clock::now();&#10;    bb31 &amp;= bb32;&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;custom bitset next_bit = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;&#10;    std::cout &lt;&lt; acc &lt;&lt; std::endl;&#10;}&#10;&#10;void subtraction_benchmark() {&#10;    std::cout &lt;&lt; &quot;Benchmark subtraction&quot; &lt;&lt; std::endl;&#10;    std::srand(static_cast&lt;unsigned&gt;(std::time(nullptr)));&#10;&#10;    std::chrono::steady_clock::time_point begin = std::chrono::steady_clock::now();&#10;    std::chrono::steady_clock::time_point end = std::chrono::steady_clock::now();&#10;&#10;    uint64_t len = 500000000;&#10;&#10;    bitarray bb1(len);&#10;    bitarray bb2(len);&#10;    custom_bitset c_bb1(len);&#10;    custom_bitset c_bb2(len);&#10;    for (uint64_t i = 0; i &lt; len; i++) {&#10;        if (rand() % 2) {&#10;            bb1.set_bit(i);&#10;            c_bb1.set_bit(i);&#10;        }&#10;    }&#10;    for (uint64_t i = 0; i &lt; len; i++) {&#10;        if (rand() % 2) {&#10;            bb2.set_bit(i);&#10;            c_bb2.set_bit(i);&#10;        }&#10;    }&#10;    // std::cout &lt;&lt; bbi;&#10;    /*&#10;    begin = std::chrono::steady_clock::now();&#10;    bb1 &amp;= ~bb2;&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;bit scan = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;    */&#10;&#10;    begin = std::chrono::steady_clock::now();&#10;    custom_bitset c_bb3 = c_bb1 - c_bb2;&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;custom bitset = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;}&#10;&#10;void test_custom_bitset() {&#10;    auto bb = custom_bitset(128);&#10;    bb.set_bit(0);&#10;    bb.set_bit(5);&#10;    bb.set_bit(10);&#10;    bb.set_bit(20);&#10;    bb.set_bit(50);&#10;    bb.set_bit(64);&#10;    bb.set_bit(63);&#10;    bb.set_bit(80);&#10;    bb.set_bit(127);&#10;    std::cout &lt;&lt; bb &lt;&lt; std::endl;&#10;    std::cout &lt;&lt; (~bb) &lt;&lt; std::endl;&#10;&#10;    auto bb2 = custom_bitset(128);&#10;    bb2.set_bit(0);&#10;    bb2.set_bit(10);&#10;    bb2.set_bit(50);&#10;    bb2.set_bit(63);&#10;    bb2.set_bit(127);&#10;    std::cout &lt;&lt; bb - bb2 &lt;&lt; std::endl;&#10;&#10;    uint64_t bit = bb.first_bit();&#10;    do {&#10;        std::cout &lt;&lt; bit &lt;&lt; &quot; &quot;;&#10;    } while((bit = bb.next_bit()) != bb.size());&#10;    std::cout &lt;&lt; std::endl;&#10;&#10;    bit = bb.last_bit();&#10;    do {&#10;        std::cout &lt;&lt; bit &lt;&lt; &quot; &quot;;&#10;    } while((bit = bb.prev_bit()) != bb.size());&#10;    std::cout &lt;&lt; std::endl;&#10;&#10;    auto bb3 = custom_bitset(bb);&#10;    auto bb4 = bb &amp; bb2;&#10;}" />
              <option name="updatedContent" value="//&#10;// Created by Beniamino Vagnarelli on 31/03/25.&#10;//&#10;&#10;#pragma once&#10;&#10;#include &lt;iostream&gt;&#10;#include &lt;chrono&gt;&#10;#include &lt;vector&gt;&#10;#include &lt;immintrin.h&gt;&#10;#include &lt;algorithm&gt;&#10;#include &lt;bitscan/bitscan.h&gt;&#10;#include &lt;graph/graph.h&gt;&#10;#include &quot;custom_bitset.h&quot;&#10;&#10;uint64_t randll() {&#10;    return (static_cast&lt;uint64_t&gt;(std::rand()) &lt;&lt; 32) | std::rand();&#10;}&#10;&#10;void bitscan_benchmark1() {&#10;    std::srand(static_cast&lt;unsigned&gt;(std::time(nullptr)));&#10;&#10;    std::chrono::steady_clock::time_point begin = std::chrono::steady_clock::now();&#10;    std::chrono::steady_clock::time_point end = std::chrono::steady_clock::now();&#10;&#10;    std::vector&lt;uint64_t&gt; numbers(50000000);&#10;    std::ranges::generate(numbers, randll);&#10;&#10;&#10;    std::cout &lt;&lt; &quot;Bit Scan Forward:&quot; &lt;&lt; std::endl;&#10;    uint64_t a = 0;&#10;&#10;    begin = std::chrono::steady_clock::now();&#10;    for (auto number : numbers) {&#10;        a += __builtin_ctzll(number);&#10;    }&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;__builtin_ctzll = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;&#10;    begin = std::chrono::steady_clock::now();&#10;    for (auto number : numbers) {&#10;        a += __bsfq(number);&#10;    }&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;__bsfq = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;&#10;    // up to 32 bits integers&#10;    /*&#10;    begin = std::chrono::steady_clock::now();&#10;    for (auto number : numbers) {&#10;        a += _bit_scan_forward(number);&#10;    }&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;_bit_scan_forward = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;    */&#10;&#10;    begin = std::chrono::steady_clock::now();&#10;    for (auto number : numbers) {&#10;        unsigned long long  Ret;&#10;        __asm__&#10;        (&#10;            &quot;bsfq %[number], %[Ret]&quot;&#10;            :[Ret] &quot;=r&quot; (Ret)&#10;            :[number] &quot;mr&quot; (number)&#10;        );&#10;        a += Ret;&#10;    }&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;asm bsfq = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;&#10;    begin = std::chrono::steady_clock::now();&#10;    for (auto number : numbers) {&#10;        a += std::countr_zero(number);&#10;    }&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;std::countr_zero = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;&#10;    std::cout &lt;&lt; std::endl;&#10;&#10;&#10;    std::cout &lt;&lt; &quot;Bit Scan Reverse&quot; &lt;&lt; std::endl;&#10;&#10;    begin = std::chrono::steady_clock::now();&#10;    for (auto number : numbers) {&#10;        a += 63 - __builtin_clzll(number);&#10;    }&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;63 - _builtin_clzll = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;&#10;    begin = std::chrono::steady_clock::now();&#10;    for (auto number : numbers) {&#10;        a += __bsrq(number);&#10;    }&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;__bsrq = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;&#10;    begin = std::chrono::steady_clock::now();&#10;    for (auto number : numbers) {&#10;        a += __builtin_ia32_bsrdi(number);&#10;    }&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;__builtin_ia32_bsrdi = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;&#10;    // up to 32 bits integers&#10;    /*&#10;    begin = std::chrono::steady_clock::now();&#10;    for (auto number : numbers) {&#10;        a += _bit_scan_reverse(number);&#10;    }&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;_bit_scan_reverse = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;    */&#10;&#10;    begin = std::chrono::steady_clock::now();&#10;    for (auto number : numbers) {&#10;         unsigned long long Ret;&#10;        __asm__&#10;        (&#10;            &quot;bsrq %[number], %[Ret]&quot;&#10;            :[Ret] &quot;=r&quot; (Ret)&#10;            :[number] &quot;mr&quot; (number)&#10;        );&#10;        a += Ret;&#10;    }&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;asm bsrq = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;&#10;    begin = std::chrono::steady_clock::now();&#10;    for (auto number : numbers) {&#10;        a += std::bit_floor(number);&#10;    }&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;std::bit_floor = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;&#10;    begin = std::chrono::steady_clock::now();&#10;    for (auto number : numbers) {&#10;        a += std::bit_width(number) - 1;&#10;    }&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;std::bit_width = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;&#10;    begin = std::chrono::steady_clock::now();&#10;    for (auto number : numbers) {&#10;        a += 63 - std::countl_zero(number);&#10;    }&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;std::countl_zero = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;&#10;    std::cout &lt;&lt; a &lt;&lt; std::endl;&#10;}&#10;&#10;&#10;void popcount_benchmark() {&#10;    std::srand(static_cast&lt;unsigned&gt;(std::time(nullptr)));&#10;&#10;    std::chrono::steady_clock::time_point begin = std::chrono::steady_clock::now();&#10;    std::chrono::steady_clock::time_point end = std::chrono::steady_clock::now();&#10;&#10;    std::vector&lt;uint64_t&gt; numbers(500000000);&#10;    std::ranges::generate(numbers, randll);&#10;&#10;&#10;    std::cout &lt;&lt; &quot;PopCount:&quot; &lt;&lt; std::endl;&#10;    uint64_t a = 0;&#10;&#10;    begin = std::chrono::steady_clock::now();&#10;    for (auto number : numbers) {&#10;        a += std::popcount(number);&#10;    }&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;std::popcount = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;&#10;    begin = std::chrono::steady_clock::now();&#10;    for (auto number : numbers) {&#10;        a += __popcount(number);&#10;    }&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;__popcount = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;&#10;    begin = std::chrono::steady_clock::now();&#10;    for (auto number : numbers) {&#10;        a += __builtin_popcountll(number);&#10;    }&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;__builtin_popcountll = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;&#10;    std::cout &lt;&lt; a &lt;&lt; std::endl;&#10;}&#10;&#10;void bit_scan_forward_benchmark() {&#10;    std::cout &lt;&lt; &quot;Benchmark bit scan forward&quot; &lt;&lt; std::endl;&#10;    std::srand(static_cast&lt;unsigned&gt;(std::time(nullptr)));&#10;&#10;    std::chrono::steady_clock::time_point begin;&#10;    std::chrono::steady_clock::time_point end;&#10;&#10;    uint64_t len = 50000000;&#10;    uint64_t acc = 0;&#10;    uint64_t bit = 0;&#10;&#10;    bitarray bb_empty(len);&#10;    bitarray bb_random(len);&#10;    bitarray bb_complete(len);&#10;    custom_bitset c_bb_empty(len);&#10;    custom_bitset c_bb_random(len);&#10;    custom_bitset c_bb_complete(len);&#10;    stateless_bitset s_bb_empty(len);&#10;    stateless_bitset s_bb_random(len);&#10;    stateless_bitset s_bb_complete(len);&#10;&#10;    for (uint64_t i = 0; i &lt; len; i++) {&#10;        if (rand() % 2) {&#10;            bb_random.set_bit(i);&#10;            c_bb_random.set_bit(i);&#10;            s_bb_random.set_bit(i);&#10;        }&#10;        bb_complete.set_bit(i);&#10;        c_bb_complete.set_bit(i);&#10;        s_bb_complete.set_bit(i);&#10;    }&#10;    bb_empty.init_scan(bbo::NON_DESTRUCTIVE);&#10;    bb_random.init_scan(bbo::NON_DESTRUCTIVE);&#10;    bb_complete.init_scan(bbo::NON_DESTRUCTIVE);&#10;&#10;    begin = std::chrono::steady_clock::now();&#10;    while(bb_empty.next_bit() != BBObject::noBit) { ++acc; }&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;bit scan empty = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;&#10;    begin = std::chrono::steady_clock::now();&#10;    bit = c_bb_empty.first_bit();&#10;    while(bit != c_bb_empty.size()) { bit = c_bb_empty.next_bit(); ++acc; }&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;custom bitset empty = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;&#10;    begin = std::chrono::steady_clock::now();&#10;    for (BitCursor cursor = s_bb_empty.first_bit(); &#10;         cursor.value != s_bb_empty.size(); &#10;         cursor = s_bb_empty.next_bit(cursor)) {&#10;        ++acc;&#10;    }&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;stateless bitset empty = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;&#10;    begin = std::chrono::steady_clock::now();&#10;    while(bb_random.next_bit() != BBObject::noBit) { ++acc; }&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;bit scan random = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;&#10;    begin = std::chrono::steady_clock::now();&#10;    bit = c_bb_random.first_bit();&#10;    while(bit != c_bb_random.size()) { bit = c_bb_random.next_bit(); ++acc; }&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;custom bitset random = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;&#10;    begin = std::chrono::steady_clock::now();&#10;    for (BitCursor cursor = s_bb_random.first_bit(); &#10;         cursor.value != s_bb_random.size(); &#10;         cursor = s_bb_random.next_bit(cursor)) {&#10;        ++acc;&#10;    }&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;stateless bitset random = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;&#10;    begin = std::chrono::steady_clock::now();&#10;    while(bb_complete.next_bit() != BBObject::noBit) { ++acc; }&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;bit scan complete = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;&#10;    begin = std::chrono::steady_clock::now();&#10;    bit = c_bb_complete.first_bit();&#10;    while(bit != c_bb_complete.size()) { bit = c_bb_complete.next_bit(); ++acc; }&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;custom bitset complete = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;&#10;    begin = std::chrono::steady_clock::now();&#10;    for (BitCursor cursor = s_bb_complete.first_bit(); &#10;         cursor.value != s_bb_complete.size(); &#10;         cursor = s_bb_complete.next_bit(cursor)) {&#10;        ++acc;&#10;    }&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;stateless bitset complete = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;&#10;    std::cout &lt;&lt; &quot;Total bits scanned: &quot; &lt;&lt; acc &lt;&lt; std::endl;&#10;}&#10;&#10;void bit_scan_forward_destructive_benchmark() {&#10;    std::cout &lt;&lt; &quot;Benchmark bit scan forward destructive&quot; &lt;&lt; std::endl;&#10;    std::srand(static_cast&lt;unsigned&gt;(std::time(nullptr)));&#10;&#10;    std::chrono::steady_clock::time_point begin;&#10;    std::chrono::steady_clock::time_point end;&#10;&#10;    uint64_t len = 50000000;&#10;    uint64_t acc = 0;&#10;    uint64_t bit = 0;&#10;&#10;    bitarray bb_empty(len);&#10;    bitarray bb_random(len);&#10;    bitarray bb_complete(len);&#10;    custom_bitset c_bb_empty(len);&#10;    custom_bitset c_bb_random(len);&#10;    custom_bitset c_bb_complete(len);&#10;    stateless_bitset s_bb_empty(len);&#10;    stateless_bitset s_bb_random(len);&#10;    stateless_bitset s_bb_complete(len);&#10;&#10;    for (uint64_t i = 0; i &lt; len; i++) {&#10;        if (rand() % 2) {&#10;            bb_random.set_bit(i);&#10;            c_bb_random.set_bit(i);&#10;            s_bb_random.set_bit(i);&#10;        }&#10;        bb_complete.set_bit(i);&#10;        c_bb_complete.set_bit(i);&#10;        s_bb_complete.set_bit(i);&#10;    }&#10;    bb_empty.init_scan(bbo::DESTRUCTIVE);&#10;    bb_random.init_scan(bbo::DESTRUCTIVE);&#10;    bb_complete.init_scan(bbo::DESTRUCTIVE);&#10;&#10;    begin = std::chrono::steady_clock::now();&#10;    while(bb_empty.next_bit() != BBObject::noBit) { ++acc; }&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;bit scan empty = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;&#10;    begin = std::chrono::steady_clock::now();&#10;    bit = c_bb_empty.first_bit_destructive();&#10;    while(bit != c_bb_empty.size()) { bit = c_bb_empty.next_bit_destructive(); ++acc; }&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;custom bitset empty = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;&#10;    begin = std::chrono::steady_clock::now();&#10;    for (BitCursor cursor = s_bb_empty.first_bit_destructive(); &#10;         cursor.value != s_bb_empty.size(); &#10;         cursor = s_bb_empty.next_bit_destructive(cursor)) {&#10;        ++acc;&#10;    }&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;stateless bitset empty = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;&#10;    begin = std::chrono::steady_clock::now();&#10;    while(bb_random.next_bit() != BBObject::noBit) { ++acc; }&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;bit scan random = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;&#10;    begin = std::chrono::steady_clock::now();&#10;    bit = c_bb_random.first_bit_destructive();&#10;    while(bit != c_bb_random.size()) { bit = c_bb_random.next_bit_destructive(); ++acc; }&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;custom bitset random = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;&#10;    begin = std::chrono::steady_clock::now();&#10;    for (BitCursor cursor = s_bb_random.first_bit_destructive(); &#10;         cursor.value != s_bb_random.size(); &#10;         cursor = s_bb_random.next_bit_destructive(cursor)) {&#10;        ++acc;&#10;    }&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;stateless bitset random = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;&#10;    begin = std::chrono::steady_clock::now();&#10;    while(bb_complete.next_bit() != BBObject::noBit) { ++acc; }&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;bit scan complete = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;&#10;    begin = std::chrono::steady_clock::now();&#10;    bit = c_bb_complete.first_bit_destructive();&#10;    while(bit != c_bb_complete.size()) { bit = c_bb_complete.next_bit_destructive(); ++acc; }&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;custom bitset complete = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;&#10;    begin = std::chrono::steady_clock::now();&#10;    for (BitCursor cursor = s_bb_complete.first_bit_destructive(); &#10;         cursor.value != s_bb_complete.size(); &#10;         cursor = s_bb_complete.next_bit_destructive(cursor)) {&#10;        ++acc;&#10;    }&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;stateless bitset complete = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;&#10;    std::cout &lt;&lt; &quot;Total bits scanned: &quot; &lt;&lt; acc &lt;&lt; std::endl;&#10;}&#10;&#10;void bit_scan_reverse_benchmark() {&#10;    std::cout &lt;&lt; &quot;Benchmark bit scan reverse&quot; &lt;&lt; std::endl;&#10;    std::srand(static_cast&lt;unsigned&gt;(std::time(nullptr)));&#10;&#10;    std::chrono::steady_clock::time_point begin;&#10;    std::chrono::steady_clock::time_point end;&#10;&#10;    uint64_t len = 50000000;&#10;    uint64_t acc = 0;&#10;    uint64_t bit = 0;&#10;&#10;    bitarray bb_empty(len);&#10;    bitarray bb_random(len);&#10;    bitarray bb_complete(len);&#10;    custom_bitset c_bb_empty(len);&#10;    custom_bitset c_bb_random(len);&#10;    custom_bitset c_bb_complete(len);&#10;    stateless_bitset s_bb_empty(len);&#10;    stateless_bitset s_bb_random(len);&#10;    stateless_bitset s_bb_complete(len);&#10;&#10;    for (uint64_t i = 0; i &lt; len; i++) {&#10;        if (rand() % 2) {&#10;            bb_random.set_bit(i);&#10;            c_bb_random.set_bit(i);&#10;            s_bb_random.set_bit(i);&#10;        }&#10;        bb_complete.set_bit(i);&#10;        c_bb_complete.set_bit(i);&#10;        s_bb_complete.set_bit(i);&#10;    }&#10;    bb_empty.init_scan(bbo::NON_DESTRUCTIVE_REVERSE);&#10;    bb_random.init_scan(bbo::NON_DESTRUCTIVE_REVERSE);&#10;    bb_complete.init_scan(bbo::NON_DESTRUCTIVE_REVERSE);&#10;&#10;    begin = std::chrono::steady_clock::now();&#10;    while(bb_empty.prev_bit() != BBObject::noBit) { ++acc; }&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;bit scan empty = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;&#10;    begin = std::chrono::steady_clock::now();&#10;    bit = c_bb_empty.last_bit();&#10;    while(bit != c_bb_empty.size()) { bit = c_bb_empty.prev_bit(); ++acc; }&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;custom bitset empty = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;&#10;    begin = std::chrono::steady_clock::now();&#10;    for (BitCursor cursor = s_bb_empty.last_bit(); &#10;         cursor.value != s_bb_empty.size(); &#10;         cursor = s_bb_empty.prev_bit(cursor)) {&#10;        ++acc;&#10;    }&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;stateless bitset empty = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;&#10;    begin = std::chrono::steady_clock::now();&#10;    while(bb_random.prev_bit() != BBObject::noBit) { ++acc; }&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;bit scan random = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;&#10;    begin = std::chrono::steady_clock::now();&#10;    bit = c_bb_random.last_bit();&#10;    while(bit != c_bb_random.size()) { bit = c_bb_random.prev_bit(); ++acc; }&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;custom bitset random = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;&#10;    begin = std::chrono::steady_clock::now();&#10;    for (BitCursor cursor = s_bb_random.last_bit(); &#10;         cursor.value != s_bb_random.size(); &#10;         cursor = s_bb_random.prev_bit(cursor)) {&#10;        ++acc;&#10;    }&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;stateless bitset random = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;&#10;    begin = std::chrono::steady_clock::now();&#10;    while(bb_complete.prev_bit() != BBObject::noBit) { ++acc; }&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;bit scan complete = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;&#10;    begin = std::chrono::steady_clock::now();&#10;    bit = c_bb_complete.last_bit();&#10;    while(bit != c_bb_complete.size()) { bit = c_bb_complete.prev_bit(); ++acc; }&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;custom bitset complete = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;&#10;    begin = std::chrono::steady_clock::now();&#10;    for (BitCursor cursor = s_bb_complete.last_bit(); &#10;         cursor.value != s_bb_complete.size(); &#10;         cursor = s_bb_complete.prev_bit(cursor)) {&#10;        ++acc;&#10;    }&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;stateless bitset complete = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;&#10;    std::cout &lt;&lt; &quot;Total bits scanned: &quot; &lt;&lt; acc &lt;&lt; std::endl;&#10;}&#10;&#10;&#10;void bitwise_and_benchmark() {&#10;    std::cout &lt;&lt; &quot;Benchmark bitwise and&quot; &lt;&lt; std::endl;&#10;    std::srand(static_cast&lt;unsigned&gt;(std::time(nullptr)));&#10;&#10;    std::chrono::steady_clock::time_point begin = std::chrono::steady_clock::now();&#10;    std::chrono::steady_clock::time_point end = std::chrono::steady_clock::now();&#10;&#10;    uint64_t len = 500000000;&#10;&#10;    uint64_t acc = 0;&#10;&#10;    bitarray bbi1(len);&#10;    bitarray bbi2(len);&#10;    custom_bitset bb31(len);&#10;    custom_bitset bb32(len);&#10;    for (uint64_t i = 0; i &lt; len; i++) {&#10;        if (rand() % 2) {&#10;            bbi1.set_bit(i);&#10;            bb31.set_bit(i);&#10;        }&#10;    }&#10;    for (uint64_t i = 0; i &lt; len; i++) {&#10;        if (rand() % 2) {&#10;            bbi2.set_bit(i);&#10;            bb32.set_bit(i);&#10;        }&#10;    }&#10;    // std::cout &lt;&lt; bbi;&#10;&#10;    begin = std::chrono::steady_clock::now();&#10;    bbi1 &amp;= bbi2;&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;bit scan = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;&#10;    begin = std::chrono::steady_clock::now();&#10;    bb31 &amp;= bb32;&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;custom bitset next_bit = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;&#10;    std::cout &lt;&lt; acc &lt;&lt; std::endl;&#10;}&#10;&#10;void subtraction_benchmark() {&#10;    std::cout &lt;&lt; &quot;Benchmark subtraction&quot; &lt;&lt; std::endl;&#10;    std::srand(static_cast&lt;unsigned&gt;(std::time(nullptr)));&#10;&#10;    std::chrono::steady_clock::time_point begin = std::chrono::steady_clock::now();&#10;    std::chrono::steady_clock::time_point end = std::chrono::steady_clock::now();&#10;&#10;    uint64_t len = 500000000;&#10;&#10;    bitarray bb1(len);&#10;    bitarray bb2(len);&#10;    custom_bitset c_bb1(len);&#10;    custom_bitset c_bb2(len);&#10;    for (uint64_t i = 0; i &lt; len; i++) {&#10;        if (rand() % 2) {&#10;            bb1.set_bit(i);&#10;            c_bb1.set_bit(i);&#10;        }&#10;    }&#10;    for (uint64_t i = 0; i &lt; len; i++) {&#10;        if (rand() % 2) {&#10;            bb2.set_bit(i);&#10;            c_bb2.set_bit(i);&#10;        }&#10;    }&#10;    // std::cout &lt;&lt; bbi;&#10;    /*&#10;    begin = std::chrono::steady_clock::now();&#10;    bb1 &amp;= ~bb2;&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;bit scan = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;    */&#10;&#10;    begin = std::chrono::steady_clock::now();&#10;    custom_bitset c_bb3 = c_bb1 - c_bb2;&#10;    end = std::chrono::steady_clock::now();&#10;    std::cout &lt;&lt; &quot;custom bitset = &quot; &lt;&lt; std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - begin).count() &lt;&lt; &quot;[s]&quot; &lt;&lt; std::endl;&#10;}&#10;&#10;void test_custom_bitset() {&#10;    auto bb = custom_bitset(128);&#10;    bb.set_bit(0);&#10;    bb.set_bit(5);&#10;    bb.set_bit(10);&#10;    bb.set_bit(20);&#10;    bb.set_bit(50);&#10;    bb.set_bit(64);&#10;    bb.set_bit(63);&#10;    bb.set_bit(80);&#10;    bb.set_bit(127);&#10;    std::cout &lt;&lt; bb &lt;&lt; std::endl;&#10;    std::cout &lt;&lt; (~bb) &lt;&lt; std::endl;&#10;&#10;    auto bb2 = custom_bitset(128);&#10;    bb2.set_bit(0);&#10;    bb2.set_bit(10);&#10;    bb2.set_bit(50);&#10;    bb2.set_bit(63);&#10;    bb2.set_bit(127);&#10;    std::cout &lt;&lt; bb - bb2 &lt;&lt; std::endl;&#10;&#10;    uint64_t bit = bb.first_bit();&#10;    do {&#10;        std::cout &lt;&lt; bit &lt;&lt; &quot; &quot;;&#10;    } while((bit = bb.next_bit()) != bb.size());&#10;    std::cout &lt;&lt; std::endl;&#10;&#10;    bit = bb.last_bit();&#10;    do {&#10;        std::cout &lt;&lt; bit &lt;&lt; &quot; &quot;;&#10;    } while((bit = bb.prev_bit()) != bb.size());&#10;    std::cout &lt;&lt; std::endl;&#10;&#10;    auto bb3 = custom_bitset(bb);&#10;    auto bb4 = bb &amp; bb2;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/custom_bitset.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/custom_bitset.h" />
              <option name="originalContent" value="//&#10;// Created by Beniamino Vagnarelli on 01/04/25.&#10;//&#10;&#10;#pragma once&#10;&#10;#include &lt;cstdint&gt;&#10;#include &lt;vector&gt;&#10;#include &lt;immintrin.h&gt; //__bsrd, __bsrq, etc&#10;#include &lt;cassert&gt;&#10;#include &lt;algorithm&gt;&#10;#include &lt;iostream&gt;&#10;&#10;/*TODO:&#10; * Destructive scans&#10; * Refactor first_bit-next_bit and last_bit-prev_bit (counter-intuitive and error-prone)&#10; */&#10;&#10;struct BitCursor {&#10;    size_t block_index;     // current block index&#10;    uint64_t bit;           // bit position inside block&#10;&#10;    // Absolute position of bit&#10;    uint64_t getPos() const {&#10;        return block_index * 64 + bit;&#10;    }&#10;};&#10;&#10;class custom_bitset {&#10;    const uint64_t _size;&#10;    std::vector&lt;uint64_t&gt; bits;&#10;    std::vector&lt;uint64_t&gt;::iterator current_block = bits.begin();&#10;    // uint64_t faster than other types&#10;    uint64_t current_bit = 0;&#10;&#10;    static uint8_t bit_scan_forward(const uint64_t x) { return __builtin_ctzll(x); }&#10;    static uint8_t bit_scan_reverse(const uint64_t x) { return __bsrq(x); }&#10;&#10;    static uint64_t get_block(const uint64_t pos) { return pos/64; };&#10;    static uint64_t get_block_bit(const uint64_t pos) { return pos%64; };&#10;&#10;    [[nodiscard]] uint64_t _next_bit(uint64_t pos) const; // used only to print&#10;&#10;public:&#10;    explicit custom_bitset(uint64_t size);&#10;    explicit custom_bitset(uint64_t size, bool default_value);&#10;    explicit custom_bitset(uint64_t size, uint64_t set_first_n_bits);&#10;    explicit custom_bitset(const std::vector&lt;uint64_t&gt;&amp; v);&#10;&#10;    custom_bitset(const std::vector&lt;uint64_t&gt; &amp;v, uint64_t size);&#10;&#10;    custom_bitset(const custom_bitset&amp; other);&#10;&#10;    custom_bitset operator&amp;(const custom_bitset&amp; other) const;&#10;    custom_bitset operator|(const custom_bitset&amp; other) const;&#10;    custom_bitset operator~() const;&#10;    custom_bitset operator-(const custom_bitset&amp; other) const;&#10;    custom_bitset&amp; operator=(const custom_bitset&amp; other);&#10;    bool operator==(const custom_bitset&amp; other) const;&#10;    custom_bitset&amp; operator&amp;=(const custom_bitset&amp; other);&#10;    custom_bitset&amp; operator|=(const custom_bitset&amp; other);&#10;    custom_bitset&amp; operator-=(const custom_bitset&amp; other);&#10;    bool operator[](const uint64_t pos) const { return get_bit(pos); };&#10;    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; stream, const custom_bitset&amp; bb);&#10;    explicit operator bool() const;&#10;    explicit operator std::vector&lt;uint64_t&gt;() const;&#10;&#10;    // TODO: not SAFE!&#10;    void set_bit(const uint64_t pos) { bits[get_block(pos)] |= 1ULL &lt;&lt; get_block_bit(pos); }&#10;    static void set_block_bit(const std::vector&lt;uint64_t&gt;::iterator &amp;block, const uint64_t &amp;bit) { *block |= 1ULL &lt;&lt; bit; }&#10;    void unset_bit(const uint64_t pos) { bits[get_block(pos)] &amp;= ~(1ULL &lt;&lt; get_block_bit(pos)); }&#10;    static void unset_block_bit(const std::vector&lt;uint64_t&gt;::iterator &amp;block, const uint64_t &amp;bit) { *block &amp;= ~(1ULL &lt;&lt; bit); }&#10;    // we move bit to first position and we mask everything that it isn't on position 1 to 0&#10;    [[nodiscard]] bool get_bit(const uint64_t pos) const { return bits[get_block(pos)] &gt;&gt; get_block_bit(pos) &amp; 1; }&#10;&#10;    void unset_all();&#10;&#10;    uint64_t first_bit();&#10;    uint64_t first_bit_destructive();&#10;    uint64_t next_bit();&#10;    uint64_t next_bit_destructive();&#10;    uint64_t last_bit();&#10;    uint64_t last_bit_destructive();&#10;    uint64_t prev_bit();&#10;    uint64_t prev_bit_destructive();&#10;&#10;    uint64_t degree() const;&#10;    uint64_t neighbors_degree() const;&#10;&#10;    void negate();&#10;&#10;    [[nodiscard]] uint64_t size() const { return _size; }&#10;    // TODO: removing caching seems beneficial. Verify that&#10;    [[nodiscard]] uint64_t n_set_bits() const {&#10;        uint64_t tot = 0;&#10;        for (const auto word : bits) {&#10;            tot += std::popcount(word);&#10;        }&#10;&#10;        return tot;&#10;    }&#10;&#10;    void swap(custom_bitset&amp; other) noexcept;&#10;};&#10;&#10;inline uint64_t custom_bitset::_next_bit(const uint64_t pos) const {&#10;    auto block = bits.begin() + get_block(pos);&#10;    auto block_bit = get_block_bit(pos);&#10;&#10;    if (pos == _size) block = bits.begin();&#10;    // shift by 64 doesn't work!! undefined behaviour&#10;    // ~1ULL is all 1's except for the lowest one, aka already shifted by one&#10;    // the resulting shift is all 1's shifted by last_bit+1&#10;    uint64_t masked_number = *block &amp; ((pos == _size) ? ~0ULL : (~1ULL &lt;&lt; block_bit));&#10;&#10;    do {&#10;        if (masked_number != 0) {&#10;            block_bit = bit_scan_forward(masked_number);&#10;            // returns the index of the current block + the current bit&#10;            return std::distance(bits.begin(), block)*64 + block_bit;&#10;            // it's equivalent but not any faster&#10;            //return std::distance(bits.begin(), last_block) &lt;&lt; 6 | last_bit;&#10;        }&#10;        masked_number = *(++block);&#10;    } while (block != bits.end());&#10;&#10;    // probably the latter is better, but in a loop it doesn't make a difference&#10;    return _size;&#10;    //return UINT64_MAX;&#10;}&#10;&#10;inline std::ostream&amp; operator&lt;&lt;(std::ostream &amp;stream, const custom_bitset &amp;bb) {&#10;    uint64_t tot = 0;&#10;    std::string tmp = &quot;[&quot;;&#10;&#10;    auto bit = bb._next_bit(bb.size());&#10;&#10;    while (bit != bb.size()) {&#10;        tmp += std::format(&quot;{} &quot;, bit);&#10;        tot++;&#10;        bit = bb._next_bit(bit);&#10;    }&#10;    tmp += std::format(&quot;({})]&quot;, tot);&#10;&#10;    return (stream &lt;&lt; tmp);&#10;}&#10;&#10;// TODO: is assert good enough?&#10;inline custom_bitset::custom_bitset(const uint64_t size): custom_bitset(size, false) {}&#10;&#10;// we set everything to 1 or to 0&#10;inline custom_bitset::custom_bitset(const uint64_t size, const bool default_value): _size(size), bits(((size-1)/64) + 1, default_value*~0ULL) {&#10;    // unset last part of last block (if there is one)&#10;    if (_size%64) bits.back() &amp;= ~(~0ULL &lt;&lt; (_size%64));&#10;}&#10;&#10;// NOT SAFE! size &gt;= set_first_n_bits&#10;inline custom_bitset::custom_bitset(const uint64_t size, const uint64_t set_first_n_bits): _size(size), bits(((size-1)/64) + 1) {&#10;    const auto n_block = (set_first_n_bits-1)/64;&#10;    const auto n_bit = set_first_n_bits%64;&#10;    for (uint64_t i = 0; i &lt;= n_block; i++) {&#10;        bits[i] = UINT64_MAX;&#10;    }&#10;    bits[n_block] &amp;= ~(~0ULL &lt;&lt; n_bit);&#10;}&#10;&#10;// TODO: change assert&#10;inline custom_bitset::custom_bitset(const std::vector&lt;uint64_t&gt; &amp;v): _size((assert(v.size()), *std::ranges::max_element(v) + 1)), bits((_size-1)/64 + 1) {&#10;    for (const auto pos: v) {&#10;        set_bit(pos);&#10;    }&#10;}&#10;&#10;// TODO: not safe&#10;inline custom_bitset::custom_bitset(const std::vector&lt;uint64_t&gt; &amp;v, uint64_t size): _size(size), bits((_size-1)/64 + 1) {&#10;    for (const auto pos: v) {&#10;        set_bit(pos);&#10;    }&#10;}&#10;&#10;inline custom_bitset::custom_bitset(const custom_bitset &amp;other): _size(other._size), bits(other.bits) {}&#10;&#10;inline custom_bitset custom_bitset::operator&amp;(const custom_bitset&amp; other) const {&#10;    if (size() &gt;= other.size()) {&#10;        custom_bitset bb(*this);&#10;        bb &amp;= other;&#10;&#10;        return bb;&#10;    } else {&#10;        custom_bitset bb(other);&#10;        bb &amp;= *this;&#10;&#10;        return bb;&#10;    }&#10;}&#10;&#10;inline custom_bitset custom_bitset::operator|(const custom_bitset&amp; other) const {&#10;    if (size() &gt;= other.size()) {&#10;        custom_bitset bb(*this);&#10;        bb |= other;&#10;&#10;        return bb;&#10;    } else {&#10;        custom_bitset bb(other);&#10;        bb |= *this;&#10;&#10;        return bb;&#10;    }&#10;}&#10;&#10;inline custom_bitset custom_bitset::operator~() const {&#10;    auto bb(*this);&#10;    bb.negate();&#10;&#10;    return bb;&#10;}&#10;&#10;inline custom_bitset custom_bitset::operator-(const custom_bitset &amp;other) const {&#10;    auto bb(*this);&#10;    bb -= other;&#10;&#10;    return bb;&#10;}&#10;&#10;inline custom_bitset&amp; custom_bitset::operator=(const custom_bitset &amp;other) {&#10;    bits = other.bits;&#10;    //current_block = other.current_block;&#10;    //current_bit = other.current_bit;&#10;&#10;    return *this;&#10;}&#10;&#10;inline bool custom_bitset::operator==(const custom_bitset &amp;other) const {&#10;    if (this == &amp;other) return true;&#10;    if (size() != other.size()) return false;&#10;&#10;    for (uint64_t i = 0; i &lt; bits.size(); i++) {&#10;        if (bits[i] != other.bits[i]) return false;&#10;    }&#10;&#10;    return true;&#10;}&#10;&#10;inline custom_bitset&amp; custom_bitset::operator&amp;=(const custom_bitset &amp;other) {&#10;    for (uint64_t i = 0; i &lt; bits.size(); ++i) {&#10;        if (i &gt;= other.bits.size()) bits[i] = 0;&#10;        else {&#10;            bits[i] &amp;= other.bits[i];&#10;        }&#10;    }&#10;&#10;    return *this;&#10;}&#10;&#10;inline custom_bitset&amp; custom_bitset::operator|=(const custom_bitset &amp;other) {&#10;    for (uint64_t i = 0; i &lt; bits.size(); ++i) {&#10;        if (i &lt; other.bits.size()) bits[i] |= other.bits[i];&#10;    }&#10;&#10;    return *this;&#10;}&#10;&#10;inline custom_bitset&amp; custom_bitset::operator-=(const custom_bitset &amp;other) {&#10;    const auto min_length = std::min(size(), other.size());&#10;    const auto min_block = (min_length-1)/64 + 1;&#10;&#10;    // equivalent to *this &amp;= ~other; but faster&#10;    for (uint64_t i = 0; i &lt; min_block; ++i) {&#10;        bits[i] &amp;= ~other.bits[i];&#10;    }&#10;&#10;    return *this;&#10;}&#10;&#10;inline custom_bitset::operator bool() const {&#10;    //std::ranges::any_of(bits, [&amp;](auto const&amp; word){ return word; });&#10;    for (const auto word:bits) {&#10;        if (word) return true;&#10;    }&#10;&#10;    return false;&#10;}&#10;&#10;inline custom_bitset::operator std::vector&lt;unsigned long&gt;() const {&#10;    auto block = bits.begin();&#10;    auto block_bit = 0;&#10;&#10;    std::vector&lt;uint64_t&gt; list;&#10;&#10;    do {&#10;        auto masked_number = *block;&#10;        while (masked_number != 0) {&#10;            block_bit = bit_scan_forward(masked_number);&#10;            list.push_back(std::distance(bits.begin(), block)*64 + block_bit);&#10;            // always shift by one even if we find 0&#10;            masked_number = *block &amp; (~1ULL &lt;&lt; block_bit);&#10;        }&#10;        ++block;&#10;    } while (block != bits.end());&#10;&#10;    return list;&#10;}&#10;&#10;inline void custom_bitset::unset_all() {&#10;    for (auto &amp;word : bits) {&#10;        word = 0;&#10;    }&#10;}&#10;&#10;inline uint64_t custom_bitset::first_bit() {&#10;    current_block = bits.begin();&#10;    current_bit = 0;&#10;&#10;    do {&#10;        if (*current_block != 0) {&#10;            current_bit = bit_scan_forward(*current_block);&#10;            // returns the index of the current block + the current bit&#10;            return std::distance(bits.begin(), current_block)*64 + current_bit;&#10;            // it's equivalent but not any faster&#10;            //return std::distance(bits.begin(), last_block) &lt;&lt; 6 | last_bit;&#10;        }&#10;        ++current_block;&#10;    } while (current_block != bits.end());&#10;&#10;    // probably the latter is better, but in a loop it doesn't make a difference&#10;    return _size;&#10;    //return UINT64_MAX;&#10;}&#10;&#10;inline uint64_t custom_bitset::first_bit_destructive() {&#10;    current_block = bits.begin();&#10;    current_bit = 0;&#10;&#10;    do {&#10;        if (*current_block != 0) {&#10;            current_bit = bit_scan_forward(*current_block);&#10;            unset_block_bit(current_block, current_bit);&#10;            // returns the index of the current block + the current bit&#10;            return std::distance(bits.begin(), current_block)*64 + current_bit;&#10;            // it's equivalent but not any faster&#10;            //return std::distance(bits.begin(), last_block) &lt;&lt; 6 | last_bit;&#10;        }&#10;        ++current_block;&#10;    } while (current_block != bits.end());&#10;&#10;    // probably the latter is better, but in a loop it doesn't make a difference&#10;    return _size;&#10;    //return UINT64_MAX;&#10;}&#10;&#10;// bug: not returning the first bit if set ...&#10;// we use first_bit to get the first bit, and we start from there...&#10;inline uint64_t custom_bitset::next_bit() {&#10;    // shift by 64 doesn't work!! undefined behaviour&#10;    // ~1ULL is all 1's except for the lowest one, aka already shifted by one&#10;    // the resulting shift is all 1's shifted by last_bit+1&#10;    uint64_t masked_number = *current_block &amp; (~1ULL &lt;&lt; current_bit);&#10;&#10;    do {&#10;        if (masked_number != 0) {&#10;            current_bit = bit_scan_forward(masked_number);&#10;            // returns the index of the current block + the current bit&#10;            return std::distance(bits.begin(), current_block)*64 + current_bit;&#10;            // it's equivalent but not any faster&#10;            //return std::distance(bits.begin(), last_block) &lt;&lt; 6 | last_bit;&#10;        }&#10;        masked_number = *(++current_block);&#10;    } while (current_block != bits.end());&#10;&#10;    // probably the latter is better, but in a loop it doesn't make a difference&#10;    return _size;&#10;    //return UINT64_MAX;&#10;}&#10;&#10;inline uint64_t custom_bitset::next_bit_destructive() {&#10;// shift by 64 doesn't work!! undefined behaviour&#10;    // ~1ULL is all 1's except for the lowest one, aka already shifted by one&#10;    // the resulting shift is all 1's shifted by last_bit+1&#10;    uint64_t masked_number = *current_block &amp; (~1ULL &lt;&lt; current_bit);&#10;&#10;    do {&#10;        if (masked_number != 0) {&#10;            current_bit = bit_scan_forward(masked_number);&#10;            unset_block_bit(current_block, current_bit);&#10;            // returns the index of the current block + the current bit&#10;            return std::distance(bits.begin(), current_block)*64 + current_bit;&#10;            // it's equivalent but not any faster&#10;            //return std::distance(bits.begin(), last_block) &lt;&lt; 6 | last_bit;&#10;        }&#10;        masked_number = *(++current_block);&#10;    } while (current_block != bits.end());&#10;&#10;    // probably the latter is better, but in a loop it doesn't make a difference&#10;    return _size;&#10;    //return UINT64_MAX;&#10;}&#10;&#10;inline uint64_t custom_bitset::last_bit() {&#10;    current_block = bits.end()-1;&#10;    current_bit = (_size-1)%64;&#10;&#10;    do {&#10;        if (*current_block != 0) {&#10;            current_bit = bit_scan_reverse(*current_block);&#10;            // returns the index of the current block + the current bit&#10;            return std::distance(bits.begin(), current_block)*64 + current_bit;&#10;            // it's equivalent but not any faster&#10;            //return std::distance(bits.begin(), last_block) &lt;&lt; 6 | last_bit;&#10;        }&#10;        --current_block;&#10;    } while (current_block != bits.begin()-1);&#10;&#10;    // probably the latter is better, but in a loop it doesn't make a difference&#10;    return _size;&#10;    //return UINT64_MAX;&#10;}&#10;&#10;inline uint64_t custom_bitset::last_bit_destructive() {&#10;    current_block = bits.end()-1;&#10;    current_bit = (_size-1)%64;&#10;&#10;    do {&#10;        if (*current_block != 0) {&#10;            current_bit = bit_scan_reverse(*current_block);&#10;            unset_block_bit(current_block, current_bit);&#10;            // returns the index of the current block + the current bit&#10;            return std::distance(bits.begin(), current_block)*64 + current_bit;&#10;            // it's equivalent but not any faster&#10;            //return std::distance(bits.begin(), last_block) &lt;&lt; 6 | last_bit;&#10;        }&#10;        --current_block;&#10;    } while (current_block != bits.begin()-1);&#10;&#10;    // probably the latter is better, but in a loop it doesn't make a difference&#10;    return _size;&#10;    //return UINT64_MAX;&#10;}&#10;&#10;inline uint64_t custom_bitset::prev_bit() {&#10;    // shift by 64 doesn't work!! undefined behaviour&#10;    // ~1ULL is all 1's except for the lowest one, aka already shifted by one&#10;    // the resulting shift is all 1's shifted by last_bit+1&#10;    uint64_t masked_number = *current_block &amp; ~(~0ULL &lt;&lt; current_bit);&#10;&#10;    //std::cout &lt;&lt; masked_number &lt;&lt; &quot; &quot; &lt;&lt; std::distance(current_block, bits.rend()) &lt;&lt; &quot; &quot; &lt;&lt; current_bit &lt;&lt; std::endl;&#10;    //std::cout &lt;&lt; std::bitset&lt;SIZEOF_WORD&gt;(masked_number).to_string() &lt;&lt; &quot; &quot; &lt;&lt; std::distance(current_block, bits.rend()) &lt;&lt; &quot; &quot; &lt;&lt; current_bit &lt;&lt; std::endl;&#10;&#10;    do {&#10;        if (masked_number != 0) {&#10;            current_bit = bit_scan_reverse(masked_number);&#10;            // returns the index of the current block + the current bit&#10;            return std::distance(bits.begin(), current_block)*64 + current_bit;&#10;            // it's equivalent but not any faster&#10;            //return std::distance(bits.begin(), last_block) &lt;&lt; 6 | last_bit;&#10;        }&#10;        masked_number = *(--current_block);&#10;    } while (current_block != bits.begin()-1);&#10;&#10;    // probably the latter is better, but in a loop it doesn't make a difference&#10;    return _size;&#10;    //return UINT64_MAX;&#10;}&#10;&#10;// TODO: optimize (use variable and update?)&#10;inline uint64_t custom_bitset::degree() const {&#10;    return n_set_bits();&#10;}&#10;&#10;inline void custom_bitset::negate() {&#10;    for (unsigned long &amp; bit : bits) {&#10;        bit = ~bit;&#10;    }&#10;    bits.back() &amp;= ~(~0ULL &lt;&lt; (_size%64));&#10;}&#10;&#10;inline void custom_bitset::swap(custom_bitset &amp;other) noexcept {&#10;    const auto tmp = *this;&#10;    *this = other;&#10;    other = tmp;&#10;}&#10;&#10;&#10;/*TODO:&#10; * Destructive scans&#10; * Refactor first_bit-next_bit and last_bit-prev_bit (counter-intuitive and error-prone)&#10; */&#10;&#10;class stateless_bitset {&#10;    const uint64_t _size;&#10;    std::vector&lt;uint64_t&gt; bits;&#10;&#10;    static uint8_t bit_scan_forward(const uint64_t x) { return __builtin_ctzll(x); }&#10;    static uint8_t bit_scan_reverse(const uint64_t x) { return __bsrq(x); }&#10;&#10;    static uint64_t get_block(const uint64_t pos) { return pos/64; };&#10;    static uint64_t get_block_bit(const uint64_t pos) { return pos%64; };&#10;&#10;    [[nodiscard]] uint64_t _next_bit(uint64_t pos) const; // used only to print&#10;&#10;public:&#10;    explicit stateless_bitset(uint64_t size);&#10;    explicit stateless_bitset(uint64_t size, bool default_value);&#10;    explicit stateless_bitset(uint64_t size, uint64_t set_first_n_bits);&#10;    explicit stateless_bitset(const std::vector&lt;uint64_t&gt;&amp; v);&#10;&#10;    stateless_bitset(const std::vector&lt;uint64_t&gt; &amp;v, uint64_t size);&#10;&#10;    stateless_bitset(const stateless_bitset&amp; other);&#10;&#10;    stateless_bitset operator&amp;(const stateless_bitset&amp; other) const;&#10;    stateless_bitset operator|(const stateless_bitset&amp; other) const;&#10;    stateless_bitset operator~() const;&#10;    stateless_bitset operator-(const stateless_bitset&amp; other) const;&#10;    stateless_bitset&amp; operator=(const stateless_bitset&amp; other);&#10;    bool operator==(const stateless_bitset&amp; other) const;&#10;    stateless_bitset&amp; operator&amp;=(const stateless_bitset&amp; other);&#10;    stateless_bitset&amp; operator|=(const stateless_bitset&amp; other);&#10;    stateless_bitset&amp; operator-=(const stateless_bitset&amp; other);&#10;    bool operator[](const uint64_t pos) const { return get_bit(pos); };&#10;    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; stream, const stateless_bitset&amp; bb);&#10;    explicit operator bool() const;&#10;    explicit operator std::vector&lt;uint64_t&gt;() const;&#10;&#10;    // TODO: not SAFE!&#10;    void set_bit(const uint64_t pos) { bits[get_block(pos)] |= 1ULL &lt;&lt; get_block_bit(pos); }&#10;    static void set_block_bit(const std::vector&lt;uint64_t&gt;::iterator &amp;block, const uint64_t &amp;bit) { *block |= 1ULL &lt;&lt; bit; }&#10;    void unset_bit(const uint64_t pos) { bits[get_block(pos)] &amp;= ~(1ULL &lt;&lt; get_block_bit(pos)); }&#10;    static void unset_block_bit(const std::vector&lt;uint64_t&gt;::iterator &amp;block, const uint64_t &amp;bit) { *block &amp;= ~(1ULL &lt;&lt; bit); }&#10;    // we move bit to first position and we mask everything that it isn't on position 1 to 0&#10;    [[nodiscard]] bool get_bit(const uint64_t pos) const { return bits[get_block(pos)] &gt;&gt; get_block_bit(pos) &amp; 1; }&#10;&#10;    void unset_all();&#10;&#10;    BitCursor first_bit() const;&#10;    BitCursor first_bit_destructive();&#10;    BitCursor next_bit(BitCursor current_bit_cursor) const;&#10;    BitCursor next_bit_destructive(BitCursor current_bit_cursor);&#10;    BitCursor last_bit() const;&#10;    BitCursor last_bit_destructive();&#10;    BitCursor prev_bit(BitCursor current_bit_cursor) const;&#10;    BitCursor prev_bit_destructive(BitCursor current_bit_cursor);&#10;&#10;    uint64_t degree() const;&#10;    uint64_t neighbors_degree() const;&#10;&#10;    void negate();&#10;&#10;    [[nodiscard]] uint64_t size() const { return _size; }&#10;    // TODO: removing caching seems beneficial. Verify that&#10;    [[nodiscard]] uint64_t n_set_bits() const {&#10;        uint64_t tot = 0;&#10;        for (const auto word : bits) {&#10;            tot += std::popcount(word);&#10;        }&#10;&#10;        return tot;&#10;    }&#10;&#10;    void swap(stateless_bitset&amp; other) noexcept;&#10;};&#10;&#10;inline uint64_t stateless_bitset::_next_bit(const uint64_t pos) const {&#10;    auto block = bits.begin() + get_block(pos);&#10;    auto block_bit = get_block_bit(pos);&#10;&#10;    if (pos == _size) block = bits.begin();&#10;    // shift by 64 doesn't work!! undefined behaviour&#10;    // ~1ULL is all 1's except for the lowest one, aka already shifted by one&#10;    // the resulting shift is all 1's shifted by last_bit+1&#10;    uint64_t masked_number = *block &amp; ((pos == _size) ? ~0ULL : (~1ULL &lt;&lt; block_bit));&#10;&#10;    do {&#10;        if (masked_number != 0) {&#10;            block_bit = bit_scan_forward(masked_number);&#10;            // returns the index of the current block + the current bit&#10;            return std::distance(bits.begin(), block)*64 + block_bit;&#10;            // it's equivalent but not any faster&#10;            //return std::distance(bits.begin(), last_block) &lt;&lt; 6 | last_bit;&#10;        }&#10;        masked_number = *(++block);&#10;    } while (block != bits.end());&#10;&#10;    // probably the latter is better, but in a loop it doesn't make a difference&#10;    return _size;&#10;    //return UINT64_MAX;&#10;}&#10;&#10;inline std::ostream&amp; operator&lt;&lt;(std::ostream &amp;stream, const stateless_bitset &amp;bb) {&#10;    uint64_t tot = 0;&#10;    std::string tmp = &quot;[&quot;;&#10;&#10;    auto bit = bb._next_bit(bb.size());&#10;&#10;    while (bit != bb.size()) {&#10;        tmp += std::format(&quot;{} &quot;, bit);&#10;        tot++;&#10;        bit = bb._next_bit(bit);&#10;    }&#10;    tmp += std::format(&quot;({})]&quot;, tot);&#10;&#10;    return (stream &lt;&lt; tmp);&#10;}&#10;&#10;// TODO: is assert good enough?&#10;inline stateless_bitset::stateless_bitset(const uint64_t size): stateless_bitset(size, false) {}&#10;&#10;// we set everything to 1 or to 0&#10;inline stateless_bitset::stateless_bitset(const uint64_t size, const bool default_value): _size(size), bits(((size-1)/64) + 1, default_value*~0ULL) {&#10;    // unset last part of last block (if there is one)&#10;    if (_size%64) bits.back() &amp;= ~(~0ULL &lt;&lt; (_size%64));&#10;}&#10;&#10;// NOT SAFE! size &gt;= set_first_n_bits&#10;inline stateless_bitset::stateless_bitset(const uint64_t size, const uint64_t set_first_n_bits): _size(size), bits(((size-1)/64) + 1) {&#10;    const auto n_block = (set_first_n_bits-1)/64;&#10;    const auto n_bit = set_first_n_bits%64;&#10;    for (uint64_t i = 0; i &lt;= n_block; i++) {&#10;        bits[i] = UINT64_MAX;&#10;    }&#10;    bits[n_block] &amp;= ~(~0ULL &lt;&lt; n_bit);&#10;}&#10;&#10;// TODO: change assert&#10;inline stateless_bitset::stateless_bitset(const std::vector&lt;uint64_t&gt; &amp;v): _size((assert(v.size()), *std::ranges::max_element(v) + 1)), bits((_size-1)/64 + 1) {&#10;    for (const auto pos: v) {&#10;        set_bit(pos);&#10;    }&#10;}&#10;&#10;// TODO: not safe&#10;inline stateless_bitset::stateless_bitset(const std::vector&lt;uint64_t&gt; &amp;v, uint64_t size): _size(size), bits((_size-1)/64 + 1) {&#10;    for (const auto pos: v) {&#10;        set_bit(pos);&#10;    }&#10;}&#10;&#10;inline stateless_bitset::stateless_bitset(const stateless_bitset &amp;other): _size(other._size), bits(other.bits) {}&#10;&#10;inline stateless_bitset stateless_bitset::operator&amp;(const stateless_bitset&amp; other) const {&#10;    if (size() &gt;= other.size()) {&#10;        stateless_bitset bb(*this);&#10;        bb &amp;= other;&#10;&#10;        return bb;&#10;    } else {&#10;        stateless_bitset bb(other);&#10;        bb &amp;= *this;&#10;&#10;        return bb;&#10;    }&#10;}&#10;&#10;inline stateless_bitset stateless_bitset::operator|(const stateless_bitset&amp; other) const {&#10;    if (size() &gt;= other.size()) {&#10;        stateless_bitset bb(*this);&#10;        bb |= other;&#10;&#10;        return bb;&#10;    } else {&#10;        stateless_bitset bb(other);&#10;        bb |= *this;&#10;&#10;        return bb;&#10;    }&#10;}&#10;&#10;inline stateless_bitset stateless_bitset::operator~() const {&#10;    auto bb(*this);&#10;    bb.negate();&#10;&#10;    return bb;&#10;}&#10;&#10;inline stateless_bitset stateless_bitset::operator-(const stateless_bitset &amp;other) const {&#10;    auto bb(*this);&#10;    bb -= other;&#10;&#10;    return bb;&#10;}&#10;&#10;inline stateless_bitset&amp; stateless_bitset::operator=(const stateless_bitset &amp;other) {&#10;    bits = other.bits;&#10;&#10;    return *this;&#10;}&#10;&#10;inline bool stateless_bitset::operator==(const stateless_bitset &amp;other) const {&#10;    if (this == &amp;other) return true;&#10;    if (size() != other.size()) return false;&#10;&#10;    for (uint64_t i = 0; i &lt; bits.size(); i++) {&#10;        if (bits[i] != other.bits[i]) return false;&#10;    }&#10;&#10;    return true;&#10;}&#10;&#10;inline stateless_bitset&amp; stateless_bitset::operator&amp;=(const stateless_bitset &amp;other) {&#10;    for (uint64_t i = 0; i &lt; bits.size(); ++i) {&#10;        if (i &gt;= other.bits.size()) bits[i] = 0;&#10;        else {&#10;            bits[i] &amp;= other.bits[i];&#10;        }&#10;    }&#10;&#10;    return *this;&#10;}&#10;&#10;inline stateless_bitset&amp; stateless_bitset::operator|=(const stateless_bitset &amp;other) {&#10;    for (uint64_t i = 0; i &lt; bits.size(); ++i) {&#10;        if (i &lt; other.bits.size()) bits[i] |= other.bits[i];&#10;    }&#10;&#10;    return *this;&#10;}&#10;&#10;inline stateless_bitset&amp; stateless_bitset::operator-=(const stateless_bitset &amp;other) {&#10;    const auto min_length = std::min(size(), other.size());&#10;    const auto min_block = (min_length-1)/64 + 1;&#10;&#10;    // equivalent to *this &amp;= ~other; but faster&#10;    for (uint64_t i = 0; i &lt; min_block; ++i) {&#10;        bits[i] &amp;= ~other.bits[i];&#10;    }&#10;&#10;    return *this;&#10;}&#10;&#10;inline stateless_bitset::operator bool() const {&#10;    //std::ranges::any_of(bits, [&amp;](auto const&amp; word){ return word; });&#10;    for (const auto word:bits) {&#10;        if (word) return true;&#10;    }&#10;&#10;    return false;&#10;}&#10;&#10;inline stateless_bitset::operator std::vector&lt;unsigned long&gt;() const {&#10;    auto block = bits.begin();&#10;    auto block_bit = 0;&#10;&#10;    std::vector&lt;uint64_t&gt; list;&#10;&#10;    do {&#10;        auto masked_number = *block;&#10;        while (masked_number != 0) {&#10;            block_bit = bit_scan_forward(masked_number);&#10;            list.push_back(std::distance(bits.begin(), block)*64 + block_bit);&#10;            // always shift by one even if we find 0&#10;            masked_number = *block &amp; (~1ULL &lt;&lt; block_bit);&#10;        }&#10;        ++block;&#10;    } while (block != bits.end());&#10;&#10;    return list;&#10;}&#10;&#10;inline void stateless_bitset::unset_all() {&#10;    for (auto &amp;word : bits) {&#10;        word = 0;&#10;    }&#10;}&#10;&#10;inline BitCursor stateless_bitset::first_bit() const {&#10;    for (size_t i = 0; i &lt; bits.size(); ++i) {&#10;        if (bits[i] != 0) {&#10;            return BitCursor{i, bit_scan_forward(bits[i])};&#10;        }&#10;    }&#10;    return BitCursor{bits.size(), 0}; // invalid cursor/end&#10;}&#10;&#10;inline BitCursor stateless_bitset::first_bit_destructive() {&#10;    for (size_t i = 0; i &lt; bits.size(); ++i) {&#10;        if (bits[i] != 0) {&#10;            uint64_t bit_pos = bit_scan_forward(bits[i]);&#10;            bits[i] &amp;= ~(1ULL &lt;&lt; bit_pos); // unset the bit&#10;            return BitCursor{i, bit_pos};&#10;        }&#10;    }&#10;    return BitCursor{bits.size(), 0}; // invalid cursor/end&#10;}&#10;&#10;inline BitCursor stateless_bitset::next_bit(BitCursor current_pos) const {&#10;    // Check remaining bits in current block&#10;    uint64_t masked_number = bits[current_pos.block_index] &amp; (~1ULL &lt;&lt; current_pos.bit);&#10;&#10;    if (masked_number != 0) {&#10;        return BitCursor{current_pos.block_index, bit_scan_forward(masked_number)};&#10;    }&#10;&#10;    // Check subsequent blocks&#10;    for (size_t i = current_pos.block_index + 1; i &lt; bits.size(); ++i) {&#10;        if (bits[i] != 0) {&#10;            return BitCursor{i, bit_scan_forward(bits[i])};&#10;        }&#10;    }&#10;&#10;    return BitCursor{bits.size(), 0}; // invalid cursor/end&#10;}&#10;&#10;inline BitCursor stateless_bitset::next_bit_destructive(BitCursor current_pos) {&#10;    // Check remaining bits in current block&#10;    uint64_t masked_number = bits[current_pos.block_index] &amp; (~1ULL &lt;&lt; current_pos.bit);&#10;&#10;    if (masked_number != 0) {&#10;        uint64_t bit_pos = bit_scan_forward(masked_number);&#10;        bits[current_pos.block_index] &amp;= ~(1ULL &lt;&lt; bit_pos);&#10;        return BitCursor{current_pos.block_index, bit_pos};&#10;    }&#10;&#10;    // Check subsequent blocks&#10;    for (size_t i = current_pos.block_index + 1; i &lt; bits.size(); ++i) {&#10;        if (bits[i] != 0) {&#10;            uint64_t bit_pos = bit_scan_forward(bits[i]);&#10;            bits[i] &amp;= ~(1ULL &lt;&lt; bit_pos);&#10;            return BitCursor{i, bit_pos};&#10;        }&#10;    }&#10;&#10;    return BitCursor{bits.size(), 0}; // invalid cursor/end&#10;}&#10;&#10;inline BitCursor stateless_bitset::last_bit() const {&#10;    for (int64_t i = bits.size() - 1; i &gt;= 0; --i) {&#10;        if (bits[i] != 0) {&#10;            return BitCursor{static_cast&lt;size_t&gt;(i), bit_scan_reverse(bits[i])};&#10;        }&#10;    }&#10;    return BitCursor{bits.size(), 0}; // invalid cursor/end&#10;}&#10;&#10;inline BitCursor stateless_bitset::last_bit_destructive() {&#10;    for (int64_t i = bits.size() - 1; i &gt;= 0; --i) {&#10;        if (bits[i] != 0) {&#10;            uint64_t bit_pos = bit_scan_reverse(bits[i]);&#10;            bits[i] &amp;= ~(1ULL &lt;&lt; bit_pos);&#10;            return BitCursor{static_cast&lt;size_t&gt;(i), bit_pos};&#10;        }&#10;    }&#10;    return BitCursor{bits.size(), 0}; // invalid cursor/end&#10;}&#10;&#10;inline BitCursor stateless_bitset::prev_bit(BitCursor current_pos) const {&#10;    // Check remaining bits in current block&#10;    uint64_t masked_number = bits[current_pos.block_index] &amp; ((1ULL &lt;&lt; current_pos.bit) - 1);&#10;&#10;    if (masked_number != 0) {&#10;        return BitCursor{current_pos.block_index, bit_scan_reverse(masked_number)};&#10;    }&#10;&#10;    // Check previous blocks&#10;    for (int64_t i = current_pos.block_index - 1; i &gt;= 0; --i) {&#10;        if (bits[i] != 0) {&#10;            return BitCursor{static_cast&lt;size_t&gt;(i), bit_scan_reverse(bits[i])};&#10;        }&#10;    }&#10;&#10;    return BitCursor{bits.size(), 0}; // invalid cursor/end&#10;}&#10;&#10;inline BitCursor stateless_bitset::prev_bit_destructive(BitCursor current_pos) {&#10;    // Check remaining bits in current block&#10;    uint64_t masked_number = bits[current_pos.block_index] &amp; ((1ULL &lt;&lt; current_pos.bit) - 1);&#10;&#10;    if (masked_number != 0) {&#10;        uint64_t bit_pos = bit_scan_reverse(masked_number);&#10;        bits[current_pos.block_index] &amp;= ~(1ULL &lt;&lt; bit_pos);&#10;        return BitCursor{current_pos.block_index, bit_pos};&#10;    }&#10;&#10;    // Check previous blocks&#10;    for (int64_t i = current_pos.block_index - 1; i &gt;= 0; --i) {&#10;        if (bits[i] != 0) {&#10;            uint64_t bit_pos = bit_scan_reverse(bits[i]);&#10;            bits[i] &amp;= ~(1ULL &lt;&lt; bit_pos);&#10;            return BitCursor{static_cast&lt;size_t&gt;(i), bit_pos};&#10;        }&#10;    }&#10;&#10;    return BitCursor{bits.size(), 0}; // invalid cursor/end&#10;}&#10;&#10;// TODO: optimize (use variable and update?)&#10;inline uint64_t stateless_bitset::degree() const {&#10;    return n_set_bits();&#10;}&#10;&#10;inline void stateless_bitset::negate() {&#10;    for (unsigned long &amp; bit : bits) {&#10;        bit = ~bit;&#10;    }&#10;    bits.back() &amp;= ~(~0ULL &lt;&lt; (_size%64));&#10;}&#10;&#10;inline void stateless_bitset::swap(stateless_bitset &amp;other) noexcept {&#10;    const auto tmp = *this;&#10;    *this = other;&#10;    other = tmp;&#10;}" />
              <option name="updatedContent" value="//&#10;// Created by Beniamino Vagnarelli on 01/04/25.&#10;//&#10;&#10;#pragma once&#10;&#10;#include &lt;cstdint&gt;&#10;#include &lt;vector&gt;&#10;#include &lt;immintrin.h&gt; //__bsrd, __bsrq, etc&#10;#include &lt;cassert&gt;&#10;#include &lt;algorithm&gt;&#10;#include &lt;iostream&gt;&#10;&#10;/*TODO:&#10; * Destructive scans&#10; * Refactor first_bit-next_bit and last_bit-prev_bit (counter-intuitive and error-prone)&#10; */&#10;&#10;struct BitCursor {&#10;    size_t block_index;     // current block index&#10;    uint64_t bit;           // bit position inside block&#10;    uint64_t value;         // absolute bit position or size() for end&#10;&#10;    // Absolute position of bit&#10;    uint64_t getPos() const {&#10;        return block_index * 64 + bit;&#10;    }&#10;};&#10;&#10;class custom_bitset {&#10;    const uint64_t _size;&#10;    std::vector&lt;uint64_t&gt; bits;&#10;    std::vector&lt;uint64_t&gt;::iterator current_block = bits.begin();&#10;    // uint64_t faster than other types&#10;    uint64_t current_bit = 0;&#10;&#10;    static uint8_t bit_scan_forward(const uint64_t x) { return __builtin_ctzll(x); }&#10;    static uint8_t bit_scan_reverse(const uint64_t x) { return __bsrq(x); }&#10;&#10;    static uint64_t get_block(const uint64_t pos) { return pos/64; };&#10;    static uint64_t get_block_bit(const uint64_t pos) { return pos%64; };&#10;&#10;    [[nodiscard]] uint64_t _next_bit(uint64_t pos) const; // used only to print&#10;&#10;public:&#10;    explicit custom_bitset(uint64_t size);&#10;    explicit custom_bitset(uint64_t size, bool default_value);&#10;    explicit custom_bitset(uint64_t size, uint64_t set_first_n_bits);&#10;    explicit custom_bitset(const std::vector&lt;uint64_t&gt;&amp; v);&#10;&#10;    custom_bitset(const std::vector&lt;uint64_t&gt; &amp;v, uint64_t size);&#10;&#10;    custom_bitset(const custom_bitset&amp; other);&#10;&#10;    custom_bitset operator&amp;(const custom_bitset&amp; other) const;&#10;    custom_bitset operator|(const custom_bitset&amp; other) const;&#10;    custom_bitset operator~() const;&#10;    custom_bitset operator-(const custom_bitset&amp; other) const;&#10;    custom_bitset&amp; operator=(const custom_bitset&amp; other);&#10;    bool operator==(const custom_bitset&amp; other) const;&#10;    custom_bitset&amp; operator&amp;=(const custom_bitset&amp; other);&#10;    custom_bitset&amp; operator|=(const custom_bitset&amp; other);&#10;    custom_bitset&amp; operator-=(const custom_bitset&amp; other);&#10;    bool operator[](const uint64_t pos) const { return get_bit(pos); };&#10;    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; stream, const custom_bitset&amp; bb);&#10;    explicit operator bool() const;&#10;    explicit operator std::vector&lt;uint64_t&gt;() const;&#10;&#10;    // TODO: not SAFE!&#10;    void set_bit(const uint64_t pos) { bits[get_block(pos)] |= 1ULL &lt;&lt; get_block_bit(pos); }&#10;    static void set_block_bit(const std::vector&lt;uint64_t&gt;::iterator &amp;block, const uint64_t &amp;bit) { *block |= 1ULL &lt;&lt; bit; }&#10;    void unset_bit(const uint64_t pos) { bits[get_block(pos)] &amp;= ~(1ULL &lt;&lt; get_block_bit(pos)); }&#10;    static void unset_block_bit(const std::vector&lt;uint64_t&gt;::iterator &amp;block, const uint64_t &amp;bit) { *block &amp;= ~(1ULL &lt;&lt; bit); }&#10;    // we move bit to first position and we mask everything that it isn't on position 1 to 0&#10;    [[nodiscard]] bool get_bit(const uint64_t pos) const { return bits[get_block(pos)] &gt;&gt; get_block_bit(pos) &amp; 1; }&#10;&#10;    void unset_all();&#10;&#10;    uint64_t first_bit();&#10;    uint64_t first_bit_destructive();&#10;    uint64_t next_bit();&#10;    uint64_t next_bit_destructive();&#10;    uint64_t last_bit();&#10;    uint64_t last_bit_destructive();&#10;    uint64_t prev_bit();&#10;    uint64_t prev_bit_destructive();&#10;&#10;    uint64_t degree() const;&#10;    uint64_t neighbors_degree() const;&#10;&#10;    void negate();&#10;&#10;    [[nodiscard]] uint64_t size() const { return _size; }&#10;    // TODO: removing caching seems beneficial. Verify that&#10;    [[nodiscard]] uint64_t n_set_bits() const {&#10;        uint64_t tot = 0;&#10;        for (const auto word : bits) {&#10;            tot += std::popcount(word);&#10;        }&#10;&#10;        return tot;&#10;    }&#10;&#10;    void swap(custom_bitset&amp; other) noexcept;&#10;};&#10;&#10;inline uint64_t custom_bitset::_next_bit(const uint64_t pos) const {&#10;    auto block = bits.begin() + get_block(pos);&#10;    auto block_bit = get_block_bit(pos);&#10;&#10;    if (pos == _size) block = bits.begin();&#10;    // shift by 64 doesn't work!! undefined behaviour&#10;    // ~1ULL is all 1's except for the lowest one, aka already shifted by one&#10;    // the resulting shift is all 1's shifted by last_bit+1&#10;    uint64_t masked_number = *block &amp; ((pos == _size) ? ~0ULL : (~1ULL &lt;&lt; block_bit));&#10;&#10;    do {&#10;        if (masked_number != 0) {&#10;            block_bit = bit_scan_forward(masked_number);&#10;            // returns the index of the current block + the current bit&#10;            return std::distance(bits.begin(), block)*64 + block_bit;&#10;            // it's equivalent but not any faster&#10;            //return std::distance(bits.begin(), last_block) &lt;&lt; 6 | last_bit;&#10;        }&#10;        masked_number = *(++block);&#10;    } while (block != bits.end());&#10;&#10;    // probably the latter is better, but in a loop it doesn't make a difference&#10;    return _size;&#10;    //return UINT64_MAX;&#10;}&#10;&#10;inline std::ostream&amp; operator&lt;&lt;(std::ostream &amp;stream, const custom_bitset &amp;bb) {&#10;    uint64_t tot = 0;&#10;    std::string tmp = &quot;[&quot;;&#10;&#10;    auto bit = bb._next_bit(bb.size());&#10;&#10;    while (bit != bb.size()) {&#10;        tmp += std::format(&quot;{} &quot;, bit);&#10;        tot++;&#10;        bit = bb._next_bit(bit);&#10;    }&#10;    tmp += std::format(&quot;({})]&quot;, tot);&#10;&#10;    return (stream &lt;&lt; tmp);&#10;}&#10;&#10;// TODO: is assert good enough?&#10;inline custom_bitset::custom_bitset(const uint64_t size): custom_bitset(size, false) {}&#10;&#10;// we set everything to 1 or to 0&#10;inline custom_bitset::custom_bitset(const uint64_t size, const bool default_value): _size(size), bits(((size-1)/64) + 1, default_value*~0ULL) {&#10;    // unset last part of last block (if there is one)&#10;    if (_size%64) bits.back() &amp;= ~(~0ULL &lt;&lt; (_size%64));&#10;}&#10;&#10;// NOT SAFE! size &gt;= set_first_n_bits&#10;inline custom_bitset::custom_bitset(const uint64_t size, const uint64_t set_first_n_bits): _size(size), bits(((size-1)/64) + 1) {&#10;    const auto n_block = (set_first_n_bits-1)/64;&#10;    const auto n_bit = set_first_n_bits%64;&#10;    for (uint64_t i = 0; i &lt;= n_block; i++) {&#10;        bits[i] = UINT64_MAX;&#10;    }&#10;    bits[n_block] &amp;= ~(~0ULL &lt;&lt; n_bit);&#10;}&#10;&#10;// TODO: change assert&#10;inline custom_bitset::custom_bitset(const std::vector&lt;uint64_t&gt; &amp;v): _size((assert(v.size()), *std::ranges::max_element(v) + 1)), bits((_size-1)/64 + 1) {&#10;    for (const auto pos: v) {&#10;        set_bit(pos);&#10;    }&#10;}&#10;&#10;// TODO: not safe&#10;inline custom_bitset::custom_bitset(const std::vector&lt;uint64_t&gt; &amp;v, uint64_t size): _size(size), bits((_size-1)/64 + 1) {&#10;    for (const auto pos: v) {&#10;        set_bit(pos);&#10;    }&#10;}&#10;&#10;inline custom_bitset::custom_bitset(const custom_bitset &amp;other): _size(other._size), bits(other.bits) {}&#10;&#10;inline custom_bitset custom_bitset::operator&amp;(const custom_bitset&amp; other) const {&#10;    if (size() &gt;= other.size()) {&#10;        custom_bitset bb(*this);&#10;        bb &amp;= other;&#10;&#10;        return bb;&#10;    } else {&#10;        custom_bitset bb(other);&#10;        bb &amp;= *this;&#10;&#10;        return bb;&#10;    }&#10;}&#10;&#10;inline custom_bitset custom_bitset::operator|(const custom_bitset&amp; other) const {&#10;    if (size() &gt;= other.size()) {&#10;        custom_bitset bb(*this);&#10;        bb |= other;&#10;&#10;        return bb;&#10;    } else {&#10;        custom_bitset bb(other);&#10;        bb |= *this;&#10;&#10;        return bb;&#10;    }&#10;}&#10;&#10;inline custom_bitset custom_bitset::operator~() const {&#10;    auto bb(*this);&#10;    bb.negate();&#10;&#10;    return bb;&#10;}&#10;&#10;inline custom_bitset custom_bitset::operator-(const custom_bitset &amp;other) const {&#10;    auto bb(*this);&#10;    bb -= other;&#10;&#10;    return bb;&#10;}&#10;&#10;inline custom_bitset&amp; custom_bitset::operator=(const custom_bitset &amp;other) {&#10;    bits = other.bits;&#10;    //current_block = other.current_block;&#10;    //current_bit = other.current_bit;&#10;&#10;    return *this;&#10;}&#10;&#10;inline bool custom_bitset::operator==(const custom_bitset &amp;other) const {&#10;    if (this == &amp;other) return true;&#10;    if (size() != other.size()) return false;&#10;&#10;    for (uint64_t i = 0; i &lt; bits.size(); i++) {&#10;        if (bits[i] != other.bits[i]) return false;&#10;    }&#10;&#10;    return true;&#10;}&#10;&#10;inline custom_bitset&amp; custom_bitset::operator&amp;=(const custom_bitset &amp;other) {&#10;    for (uint64_t i = 0; i &lt; bits.size(); ++i) {&#10;        if (i &gt;= other.bits.size()) bits[i] = 0;&#10;        else {&#10;            bits[i] &amp;= other.bits[i];&#10;        }&#10;    }&#10;&#10;    return *this;&#10;}&#10;&#10;inline custom_bitset&amp; custom_bitset::operator|=(const custom_bitset &amp;other) {&#10;    for (uint64_t i = 0; i &lt; bits.size(); ++i) {&#10;        if (i &lt; other.bits.size()) bits[i] |= other.bits[i];&#10;    }&#10;&#10;    return *this;&#10;}&#10;&#10;inline custom_bitset&amp; custom_bitset::operator-=(const custom_bitset &amp;other) {&#10;    const auto min_length = std::min(size(), other.size());&#10;    const auto min_block = (min_length-1)/64 + 1;&#10;&#10;    // equivalent to *this &amp;= ~other; but faster&#10;    for (uint64_t i = 0; i &lt; min_block; ++i) {&#10;        bits[i] &amp;= ~other.bits[i];&#10;    }&#10;&#10;    return *this;&#10;}&#10;&#10;inline custom_bitset::operator bool() const {&#10;    //std::ranges::any_of(bits, [&amp;](auto const&amp; word){ return word; });&#10;    for (const auto word:bits) {&#10;        if (word) return true;&#10;    }&#10;&#10;    return false;&#10;}&#10;&#10;inline custom_bitset::operator std::vector&lt;unsigned long&gt;() const {&#10;    auto block = bits.begin();&#10;    auto block_bit = 0;&#10;&#10;    std::vector&lt;uint64_t&gt; list;&#10;&#10;    do {&#10;        auto masked_number = *block;&#10;        while (masked_number != 0) {&#10;            block_bit = bit_scan_forward(masked_number);&#10;            list.push_back(std::distance(bits.begin(), block)*64 + block_bit);&#10;            // always shift by one even if we find 0&#10;            masked_number = *block &amp; (~1ULL &lt;&lt; block_bit);&#10;        }&#10;        ++block;&#10;    } while (block != bits.end());&#10;&#10;    return list;&#10;}&#10;&#10;inline void custom_bitset::unset_all() {&#10;    for (auto &amp;word : bits) {&#10;        word = 0;&#10;    }&#10;}&#10;&#10;inline uint64_t custom_bitset::first_bit() {&#10;    current_block = bits.begin();&#10;    current_bit = 0;&#10;&#10;    do {&#10;        if (*current_block != 0) {&#10;            current_bit = bit_scan_forward(*current_block);&#10;            // returns the index of the current block + the current bit&#10;            return std::distance(bits.begin(), current_block)*64 + current_bit;&#10;            // it's equivalent but not any faster&#10;            //return std::distance(bits.begin(), last_block) &lt;&lt; 6 | last_bit;&#10;        }&#10;        ++current_block;&#10;    } while (current_block != bits.end());&#10;&#10;    // probably the latter is better, but in a loop it doesn't make a difference&#10;    return _size;&#10;    //return UINT64_MAX;&#10;}&#10;&#10;inline uint64_t custom_bitset::first_bit_destructive() {&#10;    current_block = bits.begin();&#10;    current_bit = 0;&#10;&#10;    do {&#10;        if (*current_block != 0) {&#10;            current_bit = bit_scan_forward(*current_block);&#10;            unset_block_bit(current_block, current_bit);&#10;            // returns the index of the current block + the current bit&#10;            return std::distance(bits.begin(), current_block)*64 + current_bit;&#10;            // it's equivalent but not any faster&#10;            //return std::distance(bits.begin(), last_block) &lt;&lt; 6 | last_bit;&#10;        }&#10;        ++current_block;&#10;    } while (current_block != bits.end());&#10;&#10;    // probably the latter is better, but in a loop it doesn't make a difference&#10;    return _size;&#10;    //return UINT64_MAX;&#10;}&#10;&#10;// bug: not returning the first bit if set ...&#10;// we use first_bit to get the first bit, and we start from there...&#10;inline uint64_t custom_bitset::next_bit() {&#10;    // shift by 64 doesn't work!! undefined behaviour&#10;    // ~1ULL is all 1's except for the lowest one, aka already shifted by one&#10;    // the resulting shift is all 1's shifted by last_bit+1&#10;    uint64_t masked_number = *current_block &amp; (~1ULL &lt;&lt; current_bit);&#10;&#10;    do {&#10;        if (masked_number != 0) {&#10;            current_bit = bit_scan_forward(masked_number);&#10;            // returns the index of the current block + the current bit&#10;            return std::distance(bits.begin(), current_block)*64 + current_bit;&#10;            // it's equivalent but not any faster&#10;            //return std::distance(bits.begin(), last_block) &lt;&lt; 6 | last_bit;&#10;        }&#10;        masked_number = *(++current_block);&#10;    } while (current_block != bits.end());&#10;&#10;    // probably the latter is better, but in a loop it doesn't make a difference&#10;    return _size;&#10;    //return UINT64_MAX;&#10;}&#10;&#10;inline uint64_t custom_bitset::next_bit_destructive() {&#10;// shift by 64 doesn't work!! undefined behaviour&#10;    // ~1ULL is all 1's except for the lowest one, aka already shifted by one&#10;    // the resulting shift is all 1's shifted by last_bit+1&#10;    uint64_t masked_number = *current_block &amp; (~1ULL &lt;&lt; current_bit);&#10;&#10;    do {&#10;        if (masked_number != 0) {&#10;            current_bit = bit_scan_forward(masked_number);&#10;            unset_block_bit(current_block, current_bit);&#10;            // returns the index of the current block + the current bit&#10;            return std::distance(bits.begin(), current_block)*64 + current_bit;&#10;            // it's equivalent but not any faster&#10;            //return std::distance(bits.begin(), last_block) &lt;&lt; 6 | last_bit;&#10;        }&#10;        masked_number = *(++current_block);&#10;    } while (current_block != bits.end());&#10;&#10;    // probably the latter is better, but in a loop it doesn't make a difference&#10;    return _size;&#10;    //return UINT64_MAX;&#10;}&#10;&#10;inline uint64_t custom_bitset::last_bit() {&#10;    current_block = bits.end()-1;&#10;    current_bit = (_size-1)%64;&#10;&#10;    do {&#10;        if (*current_block != 0) {&#10;            current_bit = bit_scan_reverse(*current_block);&#10;            // returns the index of the current block + the current bit&#10;            return std::distance(bits.begin(), current_block)*64 + current_bit;&#10;            // it's equivalent but not any faster&#10;            //return std::distance(bits.begin(), last_block) &lt;&lt; 6 | last_bit;&#10;        }&#10;        --current_block;&#10;    } while (current_block != bits.begin()-1);&#10;&#10;    // probably the latter is better, but in a loop it doesn't make a difference&#10;    return _size;&#10;    //return UINT64_MAX;&#10;}&#10;&#10;inline uint64_t custom_bitset::last_bit_destructive() {&#10;    current_block = bits.end()-1;&#10;    current_bit = (_size-1)%64;&#10;&#10;    do {&#10;        if (*current_block != 0) {&#10;            current_bit = bit_scan_reverse(*current_block);&#10;            unset_block_bit(current_block, current_bit);&#10;            // returns the index of the current block + the current bit&#10;            return std::distance(bits.begin(), current_block)*64 + current_bit;&#10;            // it's equivalent but not any faster&#10;            //return std::distance(bits.begin(), last_block) &lt;&lt; 6 | last_bit;&#10;        }&#10;        --current_block;&#10;    } while (current_block != bits.begin()-1);&#10;&#10;    // probably the latter is better, but in a loop it doesn't make a difference&#10;    return _size;&#10;    //return UINT64_MAX;&#10;}&#10;&#10;inline uint64_t custom_bitset::prev_bit() {&#10;    // shift by 64 doesn't work!! undefined behaviour&#10;    // ~1ULL is all 1's except for the lowest one, aka already shifted by one&#10;    // the resulting shift is all 1's shifted by last_bit+1&#10;    uint64_t masked_number = *current_block &amp; ~(~0ULL &lt;&lt; current_bit);&#10;&#10;    //std::cout &lt;&lt; masked_number &lt;&lt; &quot; &quot; &lt;&lt; std::distance(current_block, bits.rend()) &lt;&lt; &quot; &quot; &lt;&lt; current_bit &lt;&lt; std::endl;&#10;    //std::cout &lt;&lt; std::bitset&lt;SIZEOF_WORD&gt;(masked_number).to_string() &lt;&lt; &quot; &quot; &lt;&lt; std::distance(current_block, bits.rend()) &lt;&lt; &quot; &quot; &lt;&lt; current_bit &lt;&lt; std::endl;&#10;&#10;    do {&#10;        if (masked_number != 0) {&#10;            current_bit = bit_scan_reverse(masked_number);&#10;            // returns the index of the current block + the current bit&#10;            return std::distance(bits.begin(), current_block)*64 + current_bit;&#10;            // it's equivalent but not any faster&#10;            //return std::distance(bits.begin(), last_block) &lt;&lt; 6 | last_bit;&#10;        }&#10;        masked_number = *(--current_block);&#10;    } while (current_block != bits.begin()-1);&#10;&#10;    // probably the latter is better, but in a loop it doesn't make a difference&#10;    return _size;&#10;    //return UINT64_MAX;&#10;}&#10;&#10;// TODO: optimize (use variable and update?)&#10;inline uint64_t custom_bitset::degree() const {&#10;    return n_set_bits();&#10;}&#10;&#10;inline void custom_bitset::negate() {&#10;    for (unsigned long &amp; bit : bits) {&#10;        bit = ~bit;&#10;    }&#10;    bits.back() &amp;= ~(~0ULL &lt;&lt; (_size%64));&#10;}&#10;&#10;inline void custom_bitset::swap(custom_bitset &amp;other) noexcept {&#10;    const auto tmp = *this;&#10;    *this = other;&#10;    other = tmp;&#10;}&#10;&#10;&#10;/*TODO:&#10; * Destructive scans&#10; * Refactor first_bit-next_bit and last_bit-prev_bit (counter-intuitive and error-prone)&#10; */&#10;&#10;class stateless_bitset {&#10;    const uint64_t _size;&#10;    std::vector&lt;uint64_t&gt; bits;&#10;&#10;    static uint8_t bit_scan_forward(const uint64_t x) { return __builtin_ctzll(x); }&#10;    static uint8_t bit_scan_reverse(const uint64_t x) { return __bsrq(x); }&#10;&#10;    static uint64_t get_block(const uint64_t pos) { return pos/64; };&#10;    static uint64_t get_block_bit(const uint64_t pos) { return pos%64; };&#10;&#10;    [[nodiscard]] uint64_t _next_bit(uint64_t pos) const; // used only to print&#10;&#10;public:&#10;    explicit stateless_bitset(uint64_t size);&#10;    explicit stateless_bitset(uint64_t size, bool default_value);&#10;    explicit stateless_bitset(uint64_t size, uint64_t set_first_n_bits);&#10;    explicit stateless_bitset(const std::vector&lt;uint64_t&gt;&amp; v);&#10;&#10;    stateless_bitset(const std::vector&lt;uint64_t&gt; &amp;v, uint64_t size);&#10;&#10;    stateless_bitset(const stateless_bitset&amp; other);&#10;&#10;    stateless_bitset operator&amp;(const stateless_bitset&amp; other) const;&#10;    stateless_bitset operator|(const stateless_bitset&amp; other) const;&#10;    stateless_bitset operator~() const;&#10;    stateless_bitset operator-(const stateless_bitset&amp; other) const;&#10;    stateless_bitset&amp; operator=(const stateless_bitset&amp; other);&#10;    bool operator==(const stateless_bitset&amp; other) const;&#10;    stateless_bitset&amp; operator&amp;=(const stateless_bitset&amp; other);&#10;    stateless_bitset&amp; operator|=(const stateless_bitset&amp; other);&#10;    stateless_bitset&amp; operator-=(const stateless_bitset&amp; other);&#10;    bool operator[](const uint64_t pos) const { return get_bit(pos); };&#10;    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; stream, const stateless_bitset&amp; bb);&#10;    explicit operator bool() const;&#10;    explicit operator std::vector&lt;uint64_t&gt;() const;&#10;&#10;    // TODO: not SAFE!&#10;    void set_bit(const uint64_t pos) { bits[get_block(pos)] |= 1ULL &lt;&lt; get_block_bit(pos); }&#10;    static void set_block_bit(const std::vector&lt;uint64_t&gt;::iterator &amp;block, const uint64_t &amp;bit) { *block |= 1ULL &lt;&lt; bit; }&#10;    void unset_bit(const uint64_t pos) { bits[get_block(pos)] &amp;= ~(1ULL &lt;&lt; get_block_bit(pos)); }&#10;    static void unset_block_bit(const std::vector&lt;uint64_t&gt;::iterator &amp;block, const uint64_t &amp;bit) { *block &amp;= ~(1ULL &lt;&lt; bit); }&#10;    // we move bit to first position and we mask everything that it isn't on position 1 to 0&#10;    [[nodiscard]] bool get_bit(const uint64_t pos) const { return bits[get_block(pos)] &gt;&gt; get_block_bit(pos) &amp; 1; }&#10;&#10;    void unset_all();&#10;&#10;    BitCursor first_bit() const;&#10;    BitCursor first_bit_destructive();&#10;    BitCursor next_bit(BitCursor current_bit_cursor) const;&#10;    BitCursor next_bit_destructive(BitCursor current_bit_cursor);&#10;    BitCursor last_bit() const;&#10;    BitCursor last_bit_destructive();&#10;    BitCursor prev_bit(BitCursor current_bit_cursor) const;&#10;    BitCursor prev_bit_destructive(BitCursor current_bit_cursor);&#10;&#10;    uint64_t degree() const;&#10;    uint64_t neighbors_degree() const;&#10;&#10;    void negate();&#10;&#10;    [[nodiscard]] uint64_t size() const { return _size; }&#10;    // TODO: removing caching seems beneficial. Verify that&#10;    [[nodiscard]] uint64_t n_set_bits() const {&#10;        uint64_t tot = 0;&#10;        for (const auto word : bits) {&#10;            tot += std::popcount(word);&#10;        }&#10;&#10;        return tot;&#10;    }&#10;&#10;    void swap(stateless_bitset&amp; other) noexcept;&#10;};&#10;&#10;inline uint64_t stateless_bitset::_next_bit(const uint64_t pos) const {&#10;    auto block = bits.begin() + get_block(pos);&#10;    auto block_bit = get_block_bit(pos);&#10;&#10;    if (pos == _size) block = bits.begin();&#10;    // shift by 64 doesn't work!! undefined behaviour&#10;    // ~1ULL is all 1's except for the lowest one, aka already shifted by one&#10;    // the resulting shift is all 1's shifted by last_bit+1&#10;    uint64_t masked_number = *block &amp; ((pos == _size) ? ~0ULL : (~1ULL &lt;&lt; block_bit));&#10;&#10;    do {&#10;        if (masked_number != 0) {&#10;            block_bit = bit_scan_forward(masked_number);&#10;            // returns the index of the current block + the current bit&#10;            return std::distance(bits.begin(), block)*64 + block_bit;&#10;            // it's equivalent but not any faster&#10;            //return std::distance(bits.begin(), last_block) &lt;&lt; 6 | last_bit;&#10;        }&#10;        masked_number = *(++block);&#10;    } while (block != bits.end());&#10;&#10;    // probably the latter is better, but in a loop it doesn't make a difference&#10;    return _size;&#10;    //return UINT64_MAX;&#10;}&#10;&#10;inline std::ostream&amp; operator&lt;&lt;(std::ostream &amp;stream, const stateless_bitset &amp;bb) {&#10;    uint64_t tot = 0;&#10;    std::string tmp = &quot;[&quot;;&#10;&#10;    auto bit = bb._next_bit(bb.size());&#10;&#10;    while (bit != bb.size()) {&#10;        tmp += std::format(&quot;{} &quot;, bit);&#10;        tot++;&#10;        bit = bb._next_bit(bit);&#10;    }&#10;    tmp += std::format(&quot;({})]&quot;, tot);&#10;&#10;    return (stream &lt;&lt; tmp);&#10;}&#10;&#10;// TODO: is assert good enough?&#10;inline stateless_bitset::stateless_bitset(const uint64_t size): stateless_bitset(size, false) {}&#10;&#10;// we set everything to 1 or to 0&#10;inline stateless_bitset::stateless_bitset(const uint64_t size, const bool default_value): _size(size), bits(((size-1)/64) + 1, default_value*~0ULL) {&#10;    // unset last part of last block (if there is one)&#10;    if (_size%64) bits.back() &amp;= ~(~0ULL &lt;&lt; (_size%64));&#10;}&#10;&#10;// NOT SAFE! size &gt;= set_first_n_bits&#10;inline stateless_bitset::stateless_bitset(const uint64_t size, const uint64_t set_first_n_bits): _size(size), bits(((size-1)/64) + 1) {&#10;    const auto n_block = (set_first_n_bits-1)/64;&#10;    const auto n_bit = set_first_n_bits%64;&#10;    for (uint64_t i = 0; i &lt;= n_block; i++) {&#10;        bits[i] = UINT64_MAX;&#10;    }&#10;    bits[n_block] &amp;= ~(~0ULL &lt;&lt; n_bit);&#10;}&#10;&#10;// TODO: change assert&#10;inline stateless_bitset::stateless_bitset(const std::vector&lt;uint64_t&gt; &amp;v): _size((assert(v.size()), *std::ranges::max_element(v) + 1)), bits((_size-1)/64 + 1) {&#10;    for (const auto pos: v) {&#10;        set_bit(pos);&#10;    }&#10;}&#10;&#10;// TODO: not safe&#10;inline stateless_bitset::stateless_bitset(const std::vector&lt;uint64_t&gt; &amp;v, uint64_t size): _size(size), bits((_size-1)/64 + 1) {&#10;    for (const auto pos: v) {&#10;        set_bit(pos);&#10;    }&#10;}&#10;&#10;inline stateless_bitset::stateless_bitset(const stateless_bitset &amp;other): _size(other._size), bits(other.bits) {}&#10;&#10;inline stateless_bitset stateless_bitset::operator&amp;(const stateless_bitset&amp; other) const {&#10;    if (size() &gt;= other.size()) {&#10;        stateless_bitset bb(*this);&#10;        bb &amp;= other;&#10;&#10;        return bb;&#10;    } else {&#10;        stateless_bitset bb(other);&#10;        bb &amp;= *this;&#10;&#10;        return bb;&#10;    }&#10;}&#10;&#10;inline stateless_bitset stateless_bitset::operator|(const stateless_bitset&amp; other) const {&#10;    if (size() &gt;= other.size()) {&#10;        stateless_bitset bb(*this);&#10;        bb |= other;&#10;&#10;        return bb;&#10;    } else {&#10;        stateless_bitset bb(other);&#10;        bb |= *this;&#10;&#10;        return bb;&#10;    }&#10;}&#10;&#10;inline stateless_bitset stateless_bitset::operator~() const {&#10;    auto bb(*this);&#10;    bb.negate();&#10;&#10;    return bb;&#10;}&#10;&#10;inline stateless_bitset stateless_bitset::operator-(const stateless_bitset &amp;other) const {&#10;    auto bb(*this);&#10;    bb -= other;&#10;&#10;    return bb;&#10;}&#10;&#10;inline stateless_bitset&amp; stateless_bitset::operator=(const stateless_bitset &amp;other) {&#10;    bits = other.bits;&#10;&#10;    return *this;&#10;}&#10;&#10;inline bool stateless_bitset::operator==(const stateless_bitset &amp;other) const {&#10;    if (this == &amp;other) return true;&#10;    if (size() != other.size()) return false;&#10;&#10;    for (uint64_t i = 0; i &lt; bits.size(); i++) {&#10;        if (bits[i] != other.bits[i]) return false;&#10;    }&#10;&#10;    return true;&#10;}&#10;&#10;inline stateless_bitset&amp; stateless_bitset::operator&amp;=(const stateless_bitset &amp;other) {&#10;    for (uint64_t i = 0; i &lt; bits.size(); ++i) {&#10;        if (i &gt;= other.bits.size()) bits[i] = 0;&#10;        else {&#10;            bits[i] &amp;= other.bits[i];&#10;        }&#10;    }&#10;&#10;    return *this;&#10;}&#10;&#10;inline stateless_bitset&amp; stateless_bitset::operator|=(const stateless_bitset &amp;other) {&#10;    for (uint64_t i = 0; i &lt; bits.size(); ++i) {&#10;        if (i &lt; other.bits.size()) bits[i] |= other.bits[i];&#10;    }&#10;&#10;    return *this;&#10;}&#10;&#10;inline stateless_bitset&amp; stateless_bitset::operator-=(const stateless_bitset &amp;other) {&#10;    const auto min_length = std::min(size(), other.size());&#10;    const auto min_block = (min_length-1)/64 + 1;&#10;&#10;    // equivalent to *this &amp;= ~other; but faster&#10;    for (uint64_t i = 0; i &lt; min_block; ++i) {&#10;        bits[i] &amp;= ~other.bits[i];&#10;    }&#10;&#10;    return *this;&#10;}&#10;&#10;inline stateless_bitset::operator bool() const {&#10;    //std::ranges::any_of(bits, [&amp;](auto const&amp; word){ return word; });&#10;    for (const auto word:bits) {&#10;        if (word) return true;&#10;    }&#10;&#10;    return false;&#10;}&#10;&#10;inline stateless_bitset::operator std::vector&lt;unsigned long&gt;() const {&#10;    auto block = bits.begin();&#10;    auto block_bit = 0;&#10;&#10;    std::vector&lt;uint64_t&gt; list;&#10;&#10;    do {&#10;        auto masked_number = *block;&#10;        while (masked_number != 0) {&#10;            block_bit = bit_scan_forward(masked_number);&#10;            list.push_back(std::distance(bits.begin(), block)*64 + block_bit);&#10;            // always shift by one even if we find 0&#10;            masked_number = *block &amp; (~1ULL &lt;&lt; block_bit);&#10;        }&#10;        ++block;&#10;    } while (block != bits.end());&#10;&#10;    return list;&#10;}&#10;&#10;inline void stateless_bitset::unset_all() {&#10;    for (auto &amp;word : bits) {&#10;        word = 0;&#10;    }&#10;}&#10;&#10;inline BitCursor stateless_bitset::first_bit() const {&#10;    for (size_t i = 0; i &lt; bits.size(); ++i) {&#10;        if (bits[i] != 0) {&#10;            uint64_t bit_pos = bit_scan_forward(bits[i]);&#10;            return BitCursor{i, bit_pos, i * 64 + bit_pos};&#10;        }&#10;    }&#10;    return BitCursor{bits.size(), 0, _size}; // invalid cursor/end&#10;}&#10;&#10;inline BitCursor stateless_bitset::first_bit_destructive() {&#10;    for (size_t i = 0; i &lt; bits.size(); ++i) {&#10;        if (bits[i] != 0) {&#10;            uint64_t bit_pos = bit_scan_forward(bits[i]);&#10;            bits[i] &amp;= ~(1ULL &lt;&lt; bit_pos);&#10;            return BitCursor{i, bit_pos, i * 64 + bit_pos};&#10;        }&#10;    }&#10;    return BitCursor{bits.size(), 0, _size}; // invalid cursor/end&#10;}&#10;&#10;inline BitCursor stateless_bitset::next_bit(BitCursor current_pos) const {&#10;    // Check remaining bits in current block&#10;    uint64_t masked_number = bits[current_pos.block_index] &amp; (~1ULL &lt;&lt; current_pos.bit);&#10;&#10;    if (masked_number != 0) {&#10;        uint64_t bit_pos = bit_scan_forward(masked_number);&#10;        return BitCursor{current_pos.block_index, bit_pos, current_pos.block_index * 64 + bit_pos};&#10;    }&#10;&#10;    // Check subsequent blocks&#10;    for (size_t i = current_pos.block_index + 1; i &lt; bits.size(); ++i) {&#10;        if (bits[i] != 0) {&#10;            uint64_t bit_pos = bit_scan_forward(bits[i]);&#10;            return BitCursor{i, bit_pos, i * 64 + bit_pos};&#10;        }&#10;    }&#10;&#10;    return BitCursor{bits.size(), 0, _size}; // invalid cursor/end&#10;}&#10;&#10;inline BitCursor stateless_bitset::next_bit_destructive(BitCursor current_pos) {&#10;    // Check remaining bits in current block&#10;    uint64_t masked_number = bits[current_pos.block_index] &amp; (~1ULL &lt;&lt; current_pos.bit);&#10;&#10;    if (masked_number != 0) {&#10;        uint64_t bit_pos = bit_scan_forward(masked_number);&#10;        bits[current_pos.block_index] &amp;= ~(1ULL &lt;&lt; bit_pos);&#10;        return BitCursor{current_pos.block_index, bit_pos, current_pos.block_index * 64 + bit_pos};&#10;    }&#10;&#10;    // Check subsequent blocks&#10;    for (size_t i = current_pos.block_index + 1; i &lt; bits.size(); ++i) {&#10;        if (bits[i] != 0) {&#10;            uint64_t bit_pos = bit_scan_forward(bits[i]);&#10;            bits[i] &amp;= ~(1ULL &lt;&lt; bit_pos);&#10;            return BitCursor{i, bit_pos, i * 64 + bit_pos};&#10;        }&#10;    }&#10;&#10;    return BitCursor{bits.size(), 0, _size}; // invalid cursor/end&#10;}&#10;&#10;inline BitCursor stateless_bitset::last_bit() const {&#10;    for (int64_t i = bits.size() - 1; i &gt;= 0; --i) {&#10;        if (bits[i] != 0) {&#10;            uint64_t bit_pos = bit_scan_reverse(bits[i]);&#10;            return BitCursor{static_cast&lt;size_t&gt;(i), bit_pos, static_cast&lt;size_t&gt;(i) * 64 + bit_pos};&#10;        }&#10;    }&#10;    return BitCursor{bits.size(), 0, _size}; // invalid cursor/end&#10;}&#10;&#10;inline BitCursor stateless_bitset::last_bit_destructive() {&#10;    for (int64_t i = bits.size() - 1; i &gt;= 0; --i) {&#10;        if (bits[i] != 0) {&#10;            uint64_t bit_pos = bit_scan_reverse(bits[i]);&#10;            bits[i] &amp;= ~(1ULL &lt;&lt; bit_pos);&#10;            return BitCursor{static_cast&lt;size_t&gt;(i), bit_pos, static_cast&lt;size_t&gt;(i) * 64 + bit_pos};&#10;        }&#10;    }&#10;    return BitCursor{bits.size(), 0, _size}; // invalid cursor/end&#10;}&#10;&#10;inline BitCursor stateless_bitset::prev_bit(BitCursor current_pos) const {&#10;    // Check remaining bits in current block&#10;    uint64_t masked_number = bits[current_pos.block_index] &amp; ((1ULL &lt;&lt; current_pos.bit) - 1);&#10;&#10;    if (masked_number != 0) {&#10;        uint64_t bit_pos = bit_scan_reverse(masked_number);&#10;        return BitCursor{current_pos.block_index, bit_pos, current_pos.block_index * 64 + bit_pos};&#10;    }&#10;&#10;    // Check previous blocks&#10;    for (int64_t i = current_pos.block_index - 1; i &gt;= 0; --i) {&#10;        if (bits[i] != 0) {&#10;            uint64_t bit_pos = bit_scan_reverse(bits[i]);&#10;            return BitCursor{static_cast&lt;size_t&gt;(i), bit_pos, static_cast&lt;size_t&gt;(i) * 64 + bit_pos};&#10;        }&#10;    }&#10;&#10;    return BitCursor{bits.size(), 0, _size}; // invalid cursor/end&#10;}&#10;&#10;inline BitCursor stateless_bitset::prev_bit_destructive(BitCursor current_pos) {&#10;    // Check remaining bits in current block&#10;    uint64_t masked_number = bits[current_pos.block_index] &amp; ((1ULL &lt;&lt; current_pos.bit) - 1);&#10;&#10;    if (masked_number != 0) {&#10;        uint64_t bit_pos = bit_scan_reverse(masked_number);&#10;        bits[current_pos.block_index] &amp;= ~(1ULL &lt;&lt; bit_pos);&#10;        return BitCursor{current_pos.block_index, bit_pos, current_pos.block_index * 64 + bit_pos};&#10;    }&#10;&#10;    // Check previous blocks&#10;    for (int64_t i = current_pos.block_index - 1; i &gt;= 0; --i) {&#10;        if (bits[i] != 0) {&#10;            uint64_t bit_pos = bit_scan_reverse(bits[i]);&#10;            bits[i] &amp;= ~(1ULL &lt;&lt; bit_pos);&#10;            return BitCursor{static_cast&lt;size_t&gt;(i), bit_pos, static_cast&lt;size_t&gt;(i) * 64 + bit_pos};&#10;        }&#10;    }&#10;&#10;    return BitCursor{bits.size(), 0, _size}; // invalid cursor/end&#10;}&#10;&#10;// TODO: optimize (use variable and update?)&#10;inline uint64_t stateless_bitset::degree() const {&#10;    return n_set_bits();&#10;}&#10;&#10;inline void stateless_bitset::negate() {&#10;    for (unsigned long &amp; bit : bits) {&#10;        bit = ~bit;&#10;    }&#10;    bits.back() &amp;= ~(~0ULL &lt;&lt; (_size%64));&#10;}&#10;&#10;inline void stateless_bitset::swap(stateless_bitset &amp;other) noexcept {&#10;    const auto tmp = *this;&#10;    *this = other;&#10;    other = tmp;&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/stateless_BBMC.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/stateless_BBMC.h" />
              <option name="updatedContent" value="#pragma once&#10;&#10;#include &lt;vector&gt;&#10;#include &quot;stateless_graph.h&quot;&#10;&#10;inline void BB_Color(const stateless_graph&amp; g, stateless_bitset Ubb, std::vector&lt;uint64_t&gt;&amp; Ul, std::vector&lt;uint64_t&gt;&amp; C, const int64_t k_min=0) {&#10;    static stateless_bitset Qbb(g.size());&#10;    for (int64_t k = 0; Ubb; ++k) {&#10;        Qbb = Ubb;&#10;        &#10;        for (BitCursor cursor = Qbb.first_bit(); &#10;             cursor.value != Qbb.size(); &#10;             cursor = Qbb.next_bit(cursor)) {&#10;            auto v = cursor.value;&#10;            // at most we can remove vertices, so we don't need to start a new scan&#10;            Qbb -= g.get_neighbor_set(v);&#10;&#10;            if (k &gt;= k_min) {&#10;                C[v] = k;&#10;                Ul.push_back(v);&#10;            }&#10;        }&#10;        Ubb -= Qbb;&#10;    }&#10;}&#10;&#10;inline void BBMC(const stateless_graph&amp; g, stateless_bitset&amp; Ubb, std::vector&lt;std::vector&lt;uint64_t&gt;&gt;&amp; Ul, &#10;                std::vector&lt;std::vector&lt;uint64_t&gt;&gt;&amp; C, stateless_bitset&amp; S, stateless_bitset&amp; S_max, &#10;                const uint64_t depth=0) {&#10;    while (!Ul[depth].empty()) {&#10;        const auto v = Ul[depth].back();&#10;        Ul[depth].pop_back();&#10;&#10;        Ubb.unset_bit(v);&#10;&#10;        const auto S_bits = S.n_set_bits() + 1;&#10;        const auto S_max_bits = S_max.n_set_bits();&#10;&#10;        if (S_bits + C[depth][v] &gt; S_max_bits) {&#10;            S.set_bit(v);&#10;&#10;            auto candidates = Ubb &amp; g.get_neighbor_set(v);&#10;            if (candidates) {&#10;                Ul[depth+1].clear();&#10;                const int64_t k_min = S_max_bits - S_bits;&#10;&#10;                BB_Color(g, candidates, Ul[depth+1], C[depth+1], k_min);&#10;&#10;                BBMC(g, candidates, Ul, C, S, S_max, depth+1);&#10;            } else if (S_bits &gt; S_max_bits) {&#10;                S_max = S;&#10;            }&#10;&#10;            S.unset_bit(v);&#10;        }&#10;    }&#10;}&#10;&#10;inline stateless_bitset run_BBMC(const stateless_graph &amp;g, stateless_bitset Ubb) {&#10;    // initialize Ul&#10;    std::vector&lt;std::vector&lt;uint64_t&gt;&gt; Ul(g.size());&#10;&#10;    // max branching set&#10;    stateless_bitset S(g.size());&#10;    stateless_bitset S_max(g.size());&#10;&#10;    // coloring&#10;    std::vector C(g.size(), std::vector&lt;uint64_t&gt;(g.size()));&#10;&#10;    BB_Color(g, Ubb, Ul[0], C[0]);&#10;&#10;    BBMC(g, Ubb, Ul, C, S, S_max);&#10;&#10;    return g.convert_back_set(S_max);&#10;}&#10;&#10;inline stateless_bitset run_BBMC(const stateless_graph &amp;g) {&#10;    return run_BBMC(g, stateless_bitset(g.size(), true));&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/stateless_coloring.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/stateless_coloring.h" />
              <option name="updatedContent" value="#pragma once&#10;&#10;#include &lt;cstdint&gt;&#10;#include &quot;stateless_graph.h&quot;&#10;&#10;// Independent Set Sequential&#10;// computes the chromatic number of a graph using a greedy strategy (heuristic)&#10;inline uint64_t ISEQ(const stateless_graph&amp; g, stateless_bitset Ubb) {&#10;    stateless_bitset Qbb(Ubb.size());&#10;    int64_t k = 0;&#10;    for (k = 0; Ubb; ++k) {&#10;        Qbb = Ubb;&#10;        for (BitCursor cursor = Qbb.first_bit(); &#10;             cursor.value != Qbb.size(); &#10;             cursor = Qbb.next_bit(cursor)) {&#10;            // at most we can remove vertices, so we don't need to start a new scan&#10;            Qbb -= g.get_neighbor_set(cursor.value);&#10;        }&#10;        Ubb -= Qbb;&#10;    }&#10;&#10;    return k;&#10;}&#10;&#10;// Used to get the independent sets from ISEQ&#10;inline std::vector&lt;stateless_bitset&gt; ISEQ_sets(const stateless_graph&amp; g, stateless_bitset Ubb) {&#10;    std::vector&lt;stateless_bitset&gt; independent_sets;&#10;    stateless_bitset Qbb(Ubb.size());&#10;&#10;    while (Ubb) {&#10;        Qbb = Ubb;&#10;        for (BitCursor cursor = Qbb.first_bit(); &#10;             cursor.value != Qbb.size(); &#10;             cursor = Qbb.next_bit(cursor)) {&#10;            Qbb -= g.get_neighbor_set(cursor.value);&#10;        }&#10;&#10;        independent_sets.push_back(Qbb);  // Store the independent set&#10;        Ubb -= Qbb;&#10;    }&#10;&#10;    return independent_sets;&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/stateless_graph.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/stateless_graph.h" />
              <option name="updatedContent" value="#pragma once&#10;&#10;#include &lt;fstream&gt;&#10;#include &lt;numeric&gt;&#10;#include &lt;string&gt;&#10;#include &quot;custom_bitset.h&quot;&#10;#include &lt;sstream&gt;&#10;#include &lt;ranges&gt;&#10;&#10;class stateless_graph {&#10;    std::vector&lt;stateless_bitset&gt; graph;&#10;    std::vector&lt;uint64_t&gt; order_conversion;&#10;    uint64_t n_edges = 0;&#10;&#10;public:&#10;    explicit stateless_graph(const std::string&amp; filename);&#10;    explicit stateless_graph(uint64_t size);&#10;&#10;    stateless_bitset&amp; operator[](const uint64_t pos) { return graph[pos]; };&#10;&#10;    void add_edge(uint64_t u, uint64_t v);&#10;    void remove_edge(uint64_t u, uint64_t v);&#10;&#10;    [[nodiscard]] uint64_t size() const { return graph.size(); }&#10;    [[nodiscard]] uint64_t get_n_edges() const { return n_edges; }&#10;&#10;    [[nodiscard]] const stateless_bitset&amp; get_neighbor_set(const uint64_t v) const { return graph[v]; }&#10;    [[nodiscard]] stateless_bitset get_neighbor_set(const uint64_t v, const stateless_bitset&amp; set) const { return get_neighbor_set(v) &amp; set; }&#10;    [[nodiscard]] stateless_bitset get_anti_neighbor_set(const uint64_t v) const { return ~graph[v]; }&#10;    [[nodiscard]] stateless_bitset get_anti_neighbor_set(const uint64_t v, const stateless_bitset&amp; set) const { return get_anti_neighbor_set(v) &amp; set; }&#10;&#10;    [[nodiscard]] uint64_t degree() const;&#10;    [[nodiscard]] uint64_t vertex_degree(uint64_t v) const;&#10;    [[nodiscard]] float get_density() const;&#10;&#10;    [[nodiscard]] std::vector&lt;uint64_t&gt; convert_back_set(const std::vector&lt;uint64_t&gt; &amp;v) const;&#10;    [[nodiscard]] stateless_bitset convert_back_set(stateless_bitset &amp;bb) const;&#10;    [[nodiscard]] stateless_graph get_complement() const;&#10;    [[nodiscard]] stateless_graph change_order(const std::vector&lt;uint64_t&gt;&amp; order) const;&#10;    [[nodiscard]] uint64_t get_subgraph_edges(stateless_bitset &amp;subset) const;&#10;    [[nodiscard]] std::vector&lt;uint64_t&gt; get_subgraph_vertices_degree(stateless_bitset &amp;subset) const;&#10;};&#10;&#10;inline stateless_graph::stateless_graph(const std::string&amp; filename) {&#10;    std::ifstream inf(filename);&#10;    assert(inf);&#10;&#10;    std::string strInput;&#10;    while (std::getline(inf, strInput)) {&#10;        if (strInput[0] == 'p') {&#10;            uint64_t nodes;&#10;            std::istringstream(strInput.substr(7)) &gt;&gt; nodes;&#10;&#10;            graph.reserve(nodes);&#10;            order_conversion.resize(nodes);&#10;            std::iota(order_conversion.begin(), order_conversion.end(), 0);&#10;            for (uint64_t i = 0; i &lt; nodes; ++i) {&#10;                graph.emplace_back(nodes);&#10;            }&#10;        }&#10;        else if (strInput[0] == 'e') {&#10;            uint64_t node1, node2;&#10;            std::istringstream(strInput.substr(2)) &gt;&gt; node1 &gt;&gt; node2;&#10;&#10;            add_edge(node1-1, node2-1);&#10;        }&#10;    }&#10;}&#10;&#10;inline stateless_graph::stateless_graph(const uint64_t size) &#10;    : graph(size, stateless_bitset(size)), order_conversion(size) {&#10;    std::iota(order_conversion.begin(), order_conversion.end(), 0);&#10;}&#10;&#10;// Rest of the implementation follows the same pattern as custom_graph&#10;inline void stateless_graph::add_edge(const uint64_t u, const uint64_t v) {&#10;    if (u &gt;= size() || v &gt;= size() || graph[u][v]) return;&#10;&#10;    graph[u].set_bit(v);&#10;    graph[v].set_bit(u);&#10;&#10;    n_edges++;&#10;}&#10;&#10;inline void stateless_graph::remove_edge(const uint64_t u, const uint64_t v) {&#10;    if (u &gt;= size() || v &gt;= size() || !graph[u][v]) return;&#10;&#10;    graph[u].unset_bit(v);&#10;    graph[v].unset_bit(u);&#10;&#10;    n_edges--;&#10;}&#10;&#10;inline uint64_t stateless_graph::degree() const {&#10;    uint64_t degree = 0;&#10;    for (const auto&amp; edge: graph)&#10;        degree = std::max(degree, edge.degree());&#10;    return degree;&#10;}&#10;&#10;inline uint64_t stateless_graph::vertex_degree(const uint64_t v) const {&#10;    return graph[v].n_set_bits();&#10;}&#10;&#10;inline float stateless_graph::get_density() const {&#10;    return 2.0f * static_cast&lt;float&gt;(get_n_edges()) /&#10;           (static_cast&lt;float&gt;(size()) * static_cast&lt;float&gt;(size() - 1));&#10;}&#10;&#10;inline std::vector&lt;uint64_t&gt; stateless_graph::convert_back_set(const std::vector&lt;uint64_t&gt; &amp;v) const {&#10;    std::vector&lt;uint64_t&gt; set;&#10;    set.reserve(v.size());&#10;    for (const auto vertex : v) {&#10;        set.push_back(order_conversion[vertex]);&#10;    }&#10;    return set;&#10;}&#10;&#10;inline stateless_bitset stateless_graph::convert_back_set(stateless_bitset &amp;bb) const {&#10;    stateless_bitset set(bb.size());&#10;    for (BitCursor cursor = bb.first_bit(); &#10;         cursor.getPos() != bb.size(); &#10;         cursor = bb.next_bit(cursor)) {&#10;        set.set_bit(order_conversion[cursor.getPos()]);&#10;    }&#10;    return set;&#10;}&#10;&#10;inline stateless_graph stateless_graph::get_complement() const {&#10;    stateless_graph complement(*this);&#10;    std::iota(complement.order_conversion.begin(), complement.order_conversion.end(), 0);&#10;&#10;    for (uint64_t i = 0; i &lt; complement.size(); i++) {&#10;        complement.graph[i].negate();&#10;        complement.graph[i].unset_bit(i);&#10;    }&#10;&#10;    complement.n_edges = complement.size()*(complement.size()-1)/2 - get_n_edges();&#10;    return complement;&#10;}&#10;&#10;inline stateless_graph stateless_graph::change_order(const std::vector&lt;uint64_t&gt; &amp;order) const {&#10;    stateless_graph new_g(size());&#10;    new_g.order_conversion = order;&#10;&#10;    std::vector&lt;uint64_t&gt; conversion_helper(size());&#10;    for (uint64_t i = 0; i &lt; graph.size(); i++) {&#10;        conversion_helper[order[i]] = i;&#10;    }&#10;&#10;    for (uint64_t i = 0; i &lt; size(); i++) {&#10;        const auto current_vertex = conversion_helper[i];&#10;        std::vector&lt;uint64_t&gt; set = static_cast&lt;std::vector&lt;uint64_t&gt;&gt;(graph[i]);&#10;        for (auto&amp; v : set) v = conversion_helper[v];&#10;        new_g.graph[current_vertex] = stateless_bitset(set);&#10;    }&#10;&#10;    return new_g;&#10;}&#10;&#10;inline uint64_t stateless_graph::get_subgraph_edges(stateless_bitset &amp;subset) const {&#10;    uint64_t edges = 0;&#10;    for (BitCursor cursor = subset.first_bit(); &#10;         cursor.getPos() != subset.size(); &#10;         cursor = subset.next_bit(cursor)) {&#10;        edges += (get_neighbor_set(cursor.getPos()) &amp; subset).n_set_bits();&#10;    }&#10;    return edges/2;&#10;}&#10;&#10;inline std::vector&lt;uint64_t&gt; stateless_graph::get_subgraph_vertices_degree(stateless_bitset &amp;subset) const {&#10;    std::vector&lt;uint64_t&gt; d(subset.size());&#10;    for (BitCursor cursor = subset.first_bit(); &#10;         cursor.getPos() != subset.size(); &#10;         cursor = subset.next_bit(cursor)) {&#10;        d[cursor.getPos()] = vertex_degree(cursor.getPos());&#10;    }&#10;    return d;&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/stateless_sorting.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/stateless_sorting.h" />
              <option name="originalContent" value="#pragma once&#10;&#10;#include &lt;vector&gt;&#10;#include &lt;cstdint&gt;&#10;#include &quot;stateless_graph.h&quot;&#10;#include &quot;stateless_BBMC.h&quot;&#10;#include &quot;stateless_coloring.h&quot;&#10;&#10;// Minimum Weight Sort&#10;inline std::vector&lt;uint64_t&gt; MWS(stateless_graph g) {&#10;    std::vector&lt;uint64_t&gt; vertices(g.size());&#10;    std::vector&lt;uint64_t&gt; degrees(g.size());&#10;    std::vector&lt;uint64_t&gt; neighb_deg(g.size());&#10;    std::iota(vertices.begin(), vertices.end(), 0);&#10;&#10;    for (uint64_t i = 0; i &lt; g.size(); i++) {&#10;        degrees[i] = g[i].degree();&#10;    }&#10;    for (uint64_t i = 0; i &lt; g.size(); i++) {&#10;        for (BitCursor cursor = g[i].first_bit();&#10;             cursor.getPos() != g.size();&#10;             cursor = g[i].next_bit(cursor)) {&#10;            neighb_deg[i] += degrees[cursor.getPos()];&#10;        }&#10;    }&#10;&#10;    for (uint64_t i = 1; i &lt;= g.size(); i++) {&#10;        for (uint64_t j = 0; j &lt;= g.size()-i; j++) {&#10;            auto curr_vert = vertices[j];&#10;            neighb_deg[curr_vert] = 0;&#10;            for (BitCursor cursor = g[curr_vert].first_bit();&#10;                 cursor.getPos() != g.size();&#10;                 cursor = g[curr_vert].next_bit(cursor)) {&#10;                neighb_deg[curr_vert] += degrees[cursor.getPos()];&#10;            }&#10;        }&#10;        auto v_min = std::ranges::min_element(vertices.begin(), vertices.end()-i,&#10;            [=](const uint64_t a, const uint64_t b) {&#10;                if (degrees[a] != degrees[b]) return degrees[a] &lt; degrees[b];&#10;                return neighb_deg[a] &lt; neighb_deg[b];&#10;            });&#10;&#10;        // destructive to clean graph&#10;        for (BitCursor cursor = g[*v_min].first_bit_destructive();&#10;             cursor.getPos() != g.size();&#10;             cursor = g[*v_min].next_bit_destructive(cursor)) {&#10;            degrees[cursor.getPos()]--;&#10;            g[cursor.getPos()].unset_bit(*v_min);&#10;        }&#10;        std::iter_swap(v_min, vertices.end()-i);&#10;    }&#10;&#10;    return vertices;&#10;}&#10;&#10;// DEG_SORT&#10;// Minimum Weight Sort with Initial sorting&#10;inline std::vector&lt;uint64_t&gt; MWSI(stateless_graph g, const uint64_t p=3) {&#10;    std::vector&lt;uint64_t&gt; vertices(g.size());&#10;    std::vector&lt;uint64_t&gt; degrees(g.size());&#10;    std::vector&lt;uint64_t&gt; neighb_deg(g.size());&#10;    std::iota(vertices.begin(), vertices.end(), 0);&#10;&#10;    for (uint64_t i = 0; i &lt; g.size(); i++) {&#10;        degrees[i] = g[i].degree();&#10;    }&#10;&#10;    std::vector degrees_orig = degrees;&#10;    for (uint64_t i = 0; i &lt; g.size(); i++) {&#10;        for (BitCursor cursor = g[i].first_bit();&#10;             cursor.getPos() != g.size();&#10;             cursor = g[i].next_bit(cursor)) {&#10;            neighb_deg[i] += degrees[cursor.getPos()];&#10;        }&#10;    }&#10;&#10;    const int64_t k = g.size()/p;&#10;&#10;    for (uint64_t i = 1; i &lt;= g.size(); i++) {&#10;        for (uint64_t j = 0; j &lt;= g.size()-i; j++) {&#10;            auto curr_vert = vertices[j];&#10;            neighb_deg[curr_vert] = 0;&#10;            for (BitCursor cursor = g[curr_vert].first_bit();&#10;                 cursor.getPos() != g.size();&#10;                 cursor = g[curr_vert].next_bit(cursor)) {&#10;                neighb_deg[curr_vert] += degrees[cursor.getPos()];&#10;            }&#10;        }&#10;        auto v_min = std::ranges::min_element(vertices.begin(), vertices.end()-i,&#10;            [&amp;degrees, &amp;neighb_deg](const uint64_t a, const uint64_t b) {&#10;                if (degrees[a] != degrees[b]) return degrees[a] &lt; degrees[b];&#10;                return neighb_deg[a] &lt; neighb_deg[b];&#10;            });&#10;&#10;        for (BitCursor cursor = g[*v_min].first_bit_destructive();&#10;             cursor.getPos() != g.size();&#10;             cursor = g[*v_min].next_bit_destructive(cursor)) {&#10;            degrees[cursor.getPos()]--;&#10;            g[cursor.getPos()].unset_bit(*v_min);&#10;        }&#10;        std::iter_swap(v_min, vertices.end()-i);&#10;    }&#10;&#10;    std::ranges::sort(vertices.begin(), vertices.begin()+k,&#10;        [&amp;degrees_orig](const uint64_t a, const uint64_t b) {&#10;            return degrees_orig[a] &gt; degrees_orig[b];&#10;        });&#10;&#10;    return vertices;&#10;}&#10;&#10;inline std::pair&lt;std::vector&lt;uint64_t&gt;, uint64_t&gt; COLOUR_SORT(const stateless_graph&amp; g) {&#10;    const auto g_complement = g.get_complement();&#10;&#10;    std::vector&lt;uint64_t&gt; Ocolor;&#10;    uint64_t k = 0;&#10;    stateless_bitset W(g.size(), true);&#10;&#10;    while (W) {&#10;        auto U = run_BBMC(g_complement, W);&#10;        std::vector&lt;uint64_t&gt; U_vec = static_cast&lt;std::vector&lt;uint64_t&gt;&gt;(U);&#10;&#10;        // sort by non-increasing order&#10;        std::ranges::sort(U_vec.begin(), U_vec.end(),&#10;            [&amp;g](const uint64_t a, const uint64_t b) {&#10;                return g.vertex_degree(a) &gt; g.vertex_degree(b);&#10;            });&#10;        Ocolor.insert(Ocolor.end(), U_vec.begin(), U_vec.end());&#10;        W -= U;&#10;        k++;&#10;    }&#10;&#10;    return {Ocolor, k};&#10;}&#10;&#10;inline std::pair&lt;std::vector&lt;uint64_t&gt;, uint64_t&gt; NEW_SORT(const stateless_graph &amp;g, const uint64_t p=3) {&#10;    auto Odeg = MWSI(g, p);&#10;    auto [Ocolor, k] = COLOUR_SORT(g);&#10;&#10;    return {Odeg, k};&#10;    if (g.get_density() &lt;= 0.7) return {Odeg, k};&#10;&#10;    uint64_t color_max = 0;&#10;    const auto ordered_graph = g.change_order(Odeg);&#10;    for (uint64_t i = 1; i &lt; g.size(); i++) {&#10;        stateless_bitset Ubb(i, true);&#10;        Ubb &amp;= g.get_neighbor_set(i);&#10;        color_max = std::max(color_max, ISEQ(g, Ubb));&#10;    }&#10;&#10;    uint64_t u = 1 + color_max;&#10;&#10;    if (k &lt; u) { return {Ocolor, k}; }&#10;&#10;    return {Odeg, k};&#10;}&#10;&#10;" />
              <option name="updatedContent" value="#pragma once&#10;&#10;#include &lt;vector&gt;&#10;#include &lt;cstdint&gt;&#10;#include &quot;stateless_graph.h&quot;&#10;#include &quot;stateless_BBMC.h&quot;&#10;#include &quot;stateless_coloring.h&quot;&#10;&#10;// Minimum Weight Sort&#10;inline std::vector&lt;uint64_t&gt; MWS(stateless_graph g) {&#10;    std::vector&lt;uint64_t&gt; vertices(g.size());&#10;    std::vector&lt;uint64_t&gt; degrees(g.size());&#10;    std::vector&lt;uint64_t&gt; neighb_deg(g.size());&#10;    std::iota(vertices.begin(), vertices.end(), 0);&#10;&#10;    for (uint64_t i = 0; i &lt; g.size(); i++) {&#10;        degrees[i] = g[i].degree();&#10;    }&#10;    for (uint64_t i = 0; i &lt; g.size(); i++) {&#10;        for (BitCursor cursor = g[i].first_bit();&#10;             cursor.getPos() != g.size();&#10;             cursor = g[i].next_bit(cursor)) {&#10;            neighb_deg[i] += degrees[cursor.getPos()];&#10;        }&#10;    }&#10;&#10;    for (uint64_t i = 1; i &lt;= g.size(); i++) {&#10;        for (uint64_t j = 0; j &lt;= g.size()-i; j++) {&#10;            auto curr_vert = vertices[j];&#10;            neighb_deg[curr_vert] = 0;&#10;            for (BitCursor cursor = g[curr_vert].first_bit();&#10;                 cursor.getPos() != g.size();&#10;                 cursor = g[curr_vert].next_bit(cursor)) {&#10;                neighb_deg[curr_vert] += degrees[cursor.getPos()];&#10;            }&#10;        }&#10;        auto v_min = std::ranges::min_element(vertices.begin(), vertices.end()-i,&#10;            [=](const uint64_t a, const uint64_t b) {&#10;                if (degrees[a] != degrees[b]) return degrees[a] &lt; degrees[b];&#10;                return neighb_deg[a] &lt; neighb_deg[b];&#10;            });&#10;&#10;        // destructive to clean graph&#10;        for (BitCursor cursor = g[*v_min].first_bit_destructive();&#10;             cursor.getPos() != g.size();&#10;             cursor = g[*v_min].next_bit_destructive(cursor)) {&#10;            degrees[cursor.getPos()]--;&#10;            g[cursor.getPos()].unset_bit(*v_min);&#10;        }&#10;        std::iter_swap(v_min, vertices.end()-i);&#10;    }&#10;&#10;    return vertices;&#10;}&#10;&#10;// DEG_SORT&#10;// Minimum Weight Sort with Initial sorting&#10;inline std::vector&lt;uint64_t&gt; MWSI(stateless_graph g, const uint64_t p=3) {&#10;    std::vector&lt;uint64_t&gt; vertices(g.size());&#10;    std::vector&lt;uint64_t&gt; degrees(g.size());&#10;    std::vector&lt;uint64_t&gt; neighb_deg(g.size());&#10;    std::iota(vertices.begin(), vertices.end(), 0);&#10;&#10;    for (uint64_t i = 0; i &lt; g.size(); i++) {&#10;        degrees[i] = g[i].degree();&#10;    }&#10;&#10;    std::vector degrees_orig = degrees;&#10;    for (uint64_t i = 0; i &lt; g.size(); i++) {&#10;        for (BitCursor cursor = g[i].first_bit();&#10;             cursor.getPos() != g.size();&#10;             cursor = g[i].next_bit(cursor)) {&#10;            neighb_deg[i] += degrees[cursor.getPos()];&#10;        }&#10;    }&#10;&#10;    const int64_t k = g.size()/p;&#10;&#10;    for (uint64_t i = 1; i &lt;= g.size(); i++) {&#10;        for (uint64_t j = 0; j &lt;= g.size()-i; j++) {&#10;            auto curr_vert = vertices[j];&#10;            neighb_deg[curr_vert] = 0;&#10;            for (BitCursor cursor = g[curr_vert].first_bit();&#10;                 cursor.getPos() != g.size();&#10;                 cursor = g[curr_vert].next_bit(cursor)) {&#10;                neighb_deg[curr_vert] += degrees[cursor.getPos()];&#10;            }&#10;        }&#10;        auto v_min = std::ranges::min_element(vertices.begin(), vertices.end()-i,&#10;            [&amp;degrees, &amp;neighb_deg](const uint64_t a, const uint64_t b) {&#10;                if (degrees[a] != degrees[b]) return degrees[a] &lt; degrees[b];&#10;                return neighb_deg[a] &lt; neighb_deg[b];&#10;            });&#10;&#10;        for (BitCursor cursor = g[*v_min].first_bit_destructive();&#10;             cursor.getPos() != g.size();&#10;             cursor = g[*v_min].next_bit_destructive(cursor)) {&#10;            degrees[cursor.getPos()]--;&#10;            g[cursor.getPos()].unset_bit(*v_min);&#10;        }&#10;        std::iter_swap(v_min, vertices.end()-i);&#10;    }&#10;&#10;    std::ranges::sort(vertices.begin(), vertices.begin()+k,&#10;        [&amp;degrees_orig](const uint64_t a, const uint64_t b) {&#10;            return degrees_orig[a] &gt; degrees_orig[b];&#10;        });&#10;&#10;    return vertices;&#10;}&#10;&#10;inline std::pair&lt;std::vector&lt;uint64_t&gt;, uint64_t&gt; COLOUR_SORT(const stateless_graph&amp; g) {&#10;    const auto g_complement = g.get_complement();&#10;&#10;    std::vector&lt;uint64_t&gt; Ocolor;&#10;    uint64_t k = 0;&#10;    stateless_bitset W(g.size(), true);&#10;&#10;    while (W) {&#10;        auto U = run_BBMC(g_complement, W);&#10;        std::vector&lt;uint64_t&gt; U_vec = static_cast&lt;std::vector&lt;uint64_t&gt;&gt;(U);&#10;&#10;        // sort by non-increasing order&#10;        std::ranges::sort(U_vec.begin(), U_vec.end(),&#10;            [&amp;g](const uint64_t a, const uint64_t b) {&#10;                return g.vertex_degree(a) &gt; g.vertex_degree(b);&#10;            });&#10;        Ocolor.insert(Ocolor.end(), U_vec.begin(), U_vec.end());&#10;        W -= U;&#10;        k++;&#10;    }&#10;&#10;    return {Ocolor, k};&#10;}&#10;&#10;inline std::pair&lt;std::vector&lt;uint64_t&gt;, uint64_t&gt; NEW_SORT(const stateless_graph &amp;g, const uint64_t p=3) {&#10;    auto Odeg = MWSI(g, p);&#10;    auto [Ocolor, k] = COLOUR_SORT(g);&#10;&#10;    return {Odeg, k};&#10;    if (g.get_density() &lt;= 0.7) return {Odeg, k};&#10;&#10;    uint64_t color_max = 0;&#10;    const auto ordered_graph = g.change_order(Odeg);&#10;    for (uint64_t i = 1; i &lt; g.size(); i++) {&#10;        stateless_bitset Ubb(i, true);&#10;        Ubb &amp;= g.get_neighbor_set(i);&#10;        color_max = std::max(color_max, ISEQ(g, Ubb));&#10;    }&#10;&#10;    uint64_t u = 1 + color_max;&#10;&#10;    if (k &lt; u) { return {Ocolor, k}; }&#10;&#10;    return {Odeg, k};&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>