<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/AMTS.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/AMTS.h" />
              <option name="originalContent" value="//&#10;// Created by Beniamino Vagnarelli on 10/04/25.&#10;//&#10;&#10;#pragma once&#10;#include &lt;chrono&gt;&#10;#include &lt;random&gt;&#10;&#10;#include &quot;custom_bitset.h&quot;&#10;#include &quot;custom_graph.h&quot;&#10;&#10;inline std::pair&lt;custom_bitset, bool&gt; TS(const custom_graph&amp; g, std::vector&lt;uint64_t&gt;&amp; swap_mem, custom_bitset S, const uint64_t k, const uint64_t L, uint64_t&amp; Iter, const std::chrono::time_point&lt;std::chrono::steady_clock&gt; max_time) {&#10;    uint64_t I = 0; // iterations&#10;    custom_bitset S_max = S;&#10;    std::vector&lt;uint64_t&gt; tabu_list(g.size());&#10;&#10;    // TODO: move random generator out and pass it to everything&#10;    std::mt19937 rng(std::chrono::steady_clock::now().time_since_epoch().count());&#10;    std::uniform_real_distribution&lt;&gt; real_dist(0, 1);&#10;    std::uniform_int_distribution&lt;&gt; int_dist(0, INT32_MAX);&#10;&#10;    // TODO: instead of generate everything every loop, we can update the values&#10;    while (I &lt; L) {&#10;        if (std::chrono::steady_clock::now() &gt; max_time) break;&#10;&#10;        uint64_t old_S_edges = 0;&#10;        custom_bitset S_neg = ~S;&#10;        std::vector&lt;uint64_t&gt; A;&#10;        std::vector&lt;uint64_t&gt; A_without_tabu;&#10;        std::vector&lt;uint64_t&gt; B;&#10;        std::vector&lt;uint64_t&gt; B_without_tabu;&#10;        uint64_t MinInS = 0;&#10;        uint64_t MaxOutS = 0;&#10;        std::vector&lt;uint64_t&gt; d(g.size());&#10;        for (uint64_t v = 0; v &lt; g.size(); v++) {&#10;            d[v] = (g.get_neighbor_set(v) &amp; S).n_set_bits();&#10;            // removed tabu_list check, moved later on the code&#10;            if (S.get_bit(v)) {&#10;                if (d[v] &lt; MinInS) {&#10;                    MinInS = d[v];&#10;                    A.clear();&#10;                    A_without_tabu.clear();&#10;                }&#10;                A.emplace_back(v);&#10;                if (tabu_list[v] &lt;= I) A_without_tabu.emplace_back(v);&#10;            }&#10;            else if (S_neg.get_bit(v)) {&#10;                if (d[v] &gt; MaxOutS) {&#10;                    MaxOutS = d[v];&#10;                    B.clear();&#10;                    B_without_tabu.emplace_back(v);&#10;                }&#10;                B.emplace_back(v);&#10;                if (tabu_list[v] &lt;= I) B_without_tabu.emplace_back(v);&#10;            }&#10;            old_S_edges += d[v]; //we sum every vertex degree&#10;        }&#10;        old_S_edges /= 2; // we divide by 2 (we count 2 times)&#10;&#10;        std::vector&lt;std::pair&lt;uint64_t, uint64_t&gt;&gt; T;&#10;&#10;        for (auto u : A) {&#10;            for (auto v : B) {&#10;                if (!g.get_neighbor_set(u).get_bit(v)) {&#10;                    T.emplace_back(u, v);&#10;                }&#10;            }&#10;        }&#10;&#10;        int64_t u = 0;&#10;        int64_t v = 0;&#10;        int64_t delta = 0;&#10;&#10;        if (!T.empty()) {&#10;            std::tie(u, v) = T[int_dist(rng) % T.size()];&#10;            delta = d[v] - d[u];&#10;        } else {&#10;            //TODO: in small graphs it can happen&#10;            if (A_without_tabu.empty() || B_without_tabu.empty()) {&#10;                Iter++;&#10;                I++;&#10;                continue;&#10;            }&#10;            // if no better solution is found, we need to blacklist nodes in the tabu_list&#10;            u = A_without_tabu[int_dist(rng) % A_without_tabu.size()];&#10;            v = B_without_tabu[int_dist(rng) % B_without_tabu.size()];&#10;            delta = d[v] - d[u] - 1;&#10;        }&#10;&#10;        if (delta &lt;= 0) {&#10;            // probabilistic diversifying move selection rule&#10;            // with&#10;            uint64_t l = k*(k-1)/2 - old_S_edges;&#10;            const double p = std::min(static_cast&lt;double&gt;((l + 2)/g.size()), 0.1);&#10;            const double random = real_dist(rng);&#10;            if (random &lt;= p) {&#10;                auto rand_num = int_dist(rng) % S.n_set_bits();&#10;&#10;                // select u at random from S&#10;                auto new_u = S.first_bit();&#10;                for (uint64_t i = 1; i &lt; rand_num; i++) {&#10;                    new_u = S.next_bit();&#10;                }&#10;&#10;                // select v from V\S such that d[v] &lt; integer part of k*p&#10;                auto new_v = S_neg.first_bit();&#10;                while (new_v != S_neg.size()) {&#10;                    // TODO: doesn't work (doesn't always find a v)&#10;                    if (d[new_v] &lt; static_cast&lt;uint64_t&gt;(k*g.get_density())) break;&#10;                    new_v = S_neg.next_bit();&#10;                }&#10;                if (new_v != S_neg.size()) {&#10;                    u = new_u;&#10;                    v = new_v;&#10;                }&#10;            }&#10;        }&#10;&#10;        S.unset_bit(u);&#10;        S.set_bit(v);&#10;        swap_mem[u]++;&#10;        swap_mem[v]++;&#10;&#10;        auto S_edges = g.get_subgraph_edges(S);&#10;&#10;        // TODO: we consider old or updated S for l1 calculation?&#10;        auto l1 = k*(k-1)/2 - S_edges;&#10;        auto l = std::min(l1, 10UL);&#10;        uint64_t C = std::max(k/40, 6UL);&#10;&#10;        tabu_list[u] = I + l + (int_dist(rng)%C);&#10;        tabu_list[v] = I + 0.6*l + (int_dist(rng)%static_cast&lt;uint64_t&gt;(0.6 * C));&#10;&#10;        // update tabu list&#10;&#10;&#10;        // If S is a legal k clique&#10;        if (S_edges == k*(k-1)/2) { // legal k clique&#10;            return {S, true};&#10;        }&#10;        Iter++;&#10;&#10;        if (S_edges &gt; g.get_subgraph_edges(S_max)) {&#10;            S_max = S;&#10;            I = 0;&#10;        } else {&#10;            I++;&#10;        }&#10;    }&#10;&#10;    return {S_max, false};&#10;}&#10;&#10;inline std::pair&lt;custom_bitset, bool&gt; AMTS(const custom_graph&amp; g, const uint64_t k, const uint64_t L, const uint64_t Iter_max, const std::chrono::time_point&lt;std::chrono::steady_clock&gt; max_time) {&#10;    std::vector&lt;uint64_t&gt; swap_mem(g.size());&#10;    custom_bitset S(g.size());&#10;&#10;    // construct initial Solution&#10;    for (uint64_t i = 0; i &lt; k; i++) {&#10;        auto S_neg = ~S;&#10;        uint64_t OutMaxEdge = 0;&#10;&#10;        auto v = S_neg.first_bit();&#10;        auto selected_v = v;&#10;        while (v != S_neg.size()) {&#10;            auto v_edges = (g.get_neighbor_set(v) &amp; S).n_set_bits();&#10;            if (v_edges &gt; OutMaxEdge) {&#10;                OutMaxEdge = v_edges;&#10;                selected_v = v;&#10;            }&#10;&#10;            v = S_neg.next_bit();&#10;        }&#10;&#10;        S.set_bit(selected_v);&#10;    }&#10;&#10;    custom_bitset S_max(S);&#10;    uint64_t Iter = 0;&#10;    while (Iter &lt; Iter_max) {&#10;        if (std::chrono::steady_clock::now() &gt; max_time) break;&#10;&#10;        bool is_legal_k_clique = false;&#10;        std::tie(S_max, is_legal_k_clique) = TS(g, swap_mem, S, k, L, Iter, max_time);&#10;        if (is_legal_k_clique) return {S_max, true};&#10;&#10;        //else&#10;        S.unset_all();&#10;        auto least_frequent = std::distance(swap_mem.begin(),std::min(swap_mem.begin(), swap_mem.end()));&#10;        S.set_bit(least_frequent);&#10;&#10;        // TODO: can improve?&#10;        for (uint64_t i = 1; i &lt; k; i++) {&#10;            auto S_neg = ~S;&#10;            std::vector&lt;uint64_t&gt; candidates(g.size());&#10;            uint64_t OutMaxEdge = 0;&#10;&#10;            auto v = S_neg.first_bit();&#10;            while (v != S_neg.size()) {&#10;                auto v_edges = (g.get_neighbor_set(v) &amp; S).n_set_bits();&#10;                if (v_edges &gt; OutMaxEdge) {&#10;                    OutMaxEdge = v_edges;&#10;                    candidates.clear();&#10;                }&#10;                candidates.push_back(v);&#10;&#10;                v = S_neg.next_bit();&#10;            }&#10;&#10;            auto v_min = std::ranges::min_element(candidates.begin(), candidates.end(), [&amp;swap_mem](const uint64_t a, const uint64_t b) {&#10;                return swap_mem[a] &lt; swap_mem[b];&#10;            });&#10;&#10;            S.set_bit(*v_min);&#10;        }&#10;        if (*std::min(swap_mem.begin(), swap_mem.end()) &gt; k) {&#10;            std::ranges::fill(swap_mem, 0);&#10;        }&#10;    }&#10;&#10;    return { S_max, false };&#10;}&#10;&#10;inline custom_bitset run_AMTS(const custom_graph&amp; g, int64_t run_time=50) {&#10;    auto max_time = std::chrono::steady_clock::now() + std::chrono::milliseconds(run_time);&#10;    // TODO: get complement for p &lt; 0.5&#10;    uint64_t Iter_Max = 100000000;&#10;    custom_bitset S_max(g.size());&#10;    custom_bitset S(g.size());&#10;    for (uint64_t k = 1; k &lt; g.size(); k++) {&#10;        if (std::chrono::steady_clock::now() &gt; max_time) break;&#10;&#10;        uint64_t L = g.size() * k;&#10;        // if brock or san L = 4 * k;&#10;        bool is_legal_k_clique = false;&#10;        std::tie(S, is_legal_k_clique) = AMTS(g, k, L, Iter_Max, max_time);&#10;        if (!is_legal_k_clique) return S_max;&#10;        S_max = S;&#10;    }&#10;    return S_max;&#10;}&#10;" />
              <option name="updatedContent" value="//&#10;// Created by Beniamino Vagnarelli on 10/04/25.&#10;//&#10;&#10;#pragma once&#10;#include &lt;chrono&gt;&#10;#include &lt;random&gt;&#10;&#10;#include &quot;custom_bitset.h&quot;&#10;#include &quot;custom_graph.h&quot;&#10;&#10;inline std::pair&lt;custom_bitset, bool&gt; TS(const custom_graph&amp; g, std::vector&lt;uint64_t&gt;&amp; swap_mem, custom_bitset S, const uint64_t k, const uint64_t L, uint64_t&amp; Iter, const std::chrono::time_point&lt;std::chrono::steady_clock&gt; max_time) {&#10;    uint64_t I = 0; // iterations&#10;    custom_bitset S_max = S;&#10;    std::vector&lt;uint64_t&gt; tabu_list(g.size());&#10;&#10;    // TODO: move random generator out and pass it to everything&#10;    std::mt19937 rng(std::chrono::steady_clock::now().time_since_epoch().count());&#10;    std::uniform_real_distribution&lt;&gt; real_dist(0, 1);&#10;    std::uniform_int_distribution&lt;&gt; int_dist(0, INT32_MAX);&#10;&#10;    // TODO: instead of generate everything every loop, we can update the values&#10;    while (I &lt; L) {&#10;        if (std::chrono::steady_clock::now() &gt; max_time) break;&#10;&#10;        uint64_t old_S_edges = 0;&#10;        custom_bitset S_neg = ~S;&#10;        std::vector&lt;uint64_t&gt; A;&#10;        std::vector&lt;uint64_t&gt; A_without_tabu;&#10;        std::vector&lt;uint64_t&gt; B;&#10;        std::vector&lt;uint64_t&gt; B_without_tabu;&#10;        uint64_t MinInS = 0;&#10;        uint64_t MaxOutS = 0;&#10;        std::vector&lt;uint64_t&gt; d(g.size());&#10;        for (uint64_t v = 0; v &lt; g.size(); v++) {&#10;            d[v] = (g.get_neighbor_set(v) &amp; S).n_set_bits();&#10;            // removed tabu_list check, moved later on the code&#10;            if (S.get_bit(v)) {&#10;                if (d[v] &lt; MinInS) {&#10;                    MinInS = d[v];&#10;                    A.clear();&#10;                    A_without_tabu.clear();&#10;                }&#10;                A.emplace_back(v);&#10;                if (tabu_list[v] &lt;= I) A_without_tabu.emplace_back(v);&#10;            }&#10;            else if (S_neg.get_bit(v)) {&#10;                if (d[v] &gt; MaxOutS) {&#10;                    MaxOutS = d[v];&#10;                    B.clear();&#10;                    B_without_tabu.emplace_back(v);&#10;                }&#10;                B.emplace_back(v);&#10;                if (tabu_list[v] &lt;= I) B_without_tabu.emplace_back(v);&#10;            }&#10;            old_S_edges += d[v]; //we sum every vertex degree&#10;        }&#10;        old_S_edges /= 2; // we divide by 2 (we count 2 times)&#10;&#10;        std::vector&lt;std::pair&lt;uint64_t, uint64_t&gt;&gt; T;&#10;&#10;        for (auto u : A) {&#10;            for (auto v : B) {&#10;                if (!g.get_neighbor_set(u).get_bit(v)) {&#10;                    T.emplace_back(u, v);&#10;                }&#10;            }&#10;        }&#10;&#10;        int64_t u = 0;&#10;        int64_t v = 0;&#10;        int64_t delta = 0;&#10;&#10;        if (!T.empty()) {&#10;            std::tie(u, v) = T[int_dist(rng) % T.size()];&#10;            delta = d[v] - d[u];&#10;        } else {&#10;            //TODO: in small graphs it can happen&#10;            if (A_without_tabu.empty() || B_without_tabu.empty()) {&#10;                Iter++;&#10;                I++;&#10;                continue;&#10;            }&#10;            // if no better solution is found, we need to blacklist nodes in the tabu_list&#10;            u = A_without_tabu[int_dist(rng) % A_without_tabu.size()];&#10;            v = B_without_tabu[int_dist(rng) % B_without_tabu.size()];&#10;            delta = d[v] - d[u] - 1;&#10;        }&#10;&#10;        if (delta &lt;= 0) {&#10;            uint64_t l = k*(k-1)/2 - old_S_edges;&#10;            const double p = std::min(static_cast&lt;double&gt;((l + 2)/g.size()), 0.1);&#10;            const double random = real_dist(rng);&#10;            if (random &lt;= p) {&#10;                auto rand_num = int_dist(rng) % S.n_set_bits();&#10;&#10;                // select u at random from S&#10;                BitCursor new_u = S.first_bit();&#10;                for (uint64_t i = 1; i &lt; rand_num; i++) {&#10;                    new_u = S.next_bit(new_u);&#10;                }&#10;&#10;                // select v from V\S such that d[v] &lt; integer part of k*p&#10;                BitCursor new_v = S_neg.first_bit();&#10;                while (new_v.getPos() != S_neg.size()) {&#10;                    if (d[new_v.getPos()] &lt; static_cast&lt;uint64_t&gt;(k*g.get_density())) break;&#10;                    new_v = S_neg.next_bit(new_v);&#10;                }&#10;                if (new_v.getPos() != S_neg.size()) {&#10;                    u = new_u.getPos();&#10;                    v = new_v.getPos();&#10;                }&#10;            }&#10;        }&#10;&#10;        S.unset_bit(u);&#10;        S.set_bit(v);&#10;        swap_mem[u]++;&#10;        swap_mem[v]++;&#10;&#10;        auto S_edges = g.get_subgraph_edges(S);&#10;&#10;        // TODO: we consider old or updated S for l1 calculation?&#10;        auto l1 = k*(k-1)/2 - S_edges;&#10;        auto l = std::min(l1, 10UL);&#10;        uint64_t C = std::max(k/40, 6UL);&#10;&#10;        tabu_list[u] = I + l + (int_dist(rng)%C);&#10;        tabu_list[v] = I + 0.6*l + (int_dist(rng)%static_cast&lt;uint64_t&gt;(0.6 * C));&#10;&#10;        // update tabu list&#10;&#10;&#10;        // If S is a legal k clique&#10;        if (S_edges == k*(k-1)/2) { // legal k clique&#10;            return {S, true};&#10;        }&#10;        Iter++;&#10;&#10;        if (S_edges &gt; g.get_subgraph_edges(S_max)) {&#10;            S_max = S;&#10;            I = 0;&#10;        } else {&#10;            I++;&#10;        }&#10;    }&#10;&#10;    return {S_max, false};&#10;}&#10;&#10;inline std::pair&lt;custom_bitset, bool&gt; AMTS(const custom_graph&amp; g, const uint64_t k, const uint64_t L, const uint64_t Iter_max, const std::chrono::time_point&lt;std::chrono::steady_clock&gt; max_time) {&#10;    std::vector&lt;uint64_t&gt; swap_mem(g.size());&#10;    custom_bitset S(g.size());&#10;&#10;    // construct initial Solution&#10;    for (uint64_t i = 0; i &lt; k; i++) {&#10;        auto S_neg = ~S;&#10;        uint64_t OutMaxEdge = 0;&#10;&#10;        BitCursor v = S_neg.first_bit();&#10;        BitCursor selected_v = v;&#10;        while (v.getPos() != S_neg.size()) {&#10;            auto v_edges = (g.get_neighbor_set(v.getPos()) &amp; S).n_set_bits();&#10;            if (v_edges &gt; OutMaxEdge) {&#10;                OutMaxEdge = v_edges;&#10;                selected_v = v;&#10;            }&#10;&#10;            v = S_neg.next_bit(v);&#10;        }&#10;&#10;        S.set_bit(selected_v.getPos());&#10;    }&#10;&#10;    custom_bitset S_max(S);&#10;    uint64_t Iter = 0;&#10;    while (Iter &lt; Iter_max) {&#10;        if (std::chrono::steady_clock::now() &gt; max_time) break;&#10;&#10;        bool is_legal_k_clique = false;&#10;        std::tie(S_max, is_legal_k_clique) = TS(g, swap_mem, S, k, L, Iter, max_time);&#10;        if (is_legal_k_clique) return {S_max, true};&#10;&#10;        //else&#10;        S.unset_all();&#10;        auto least_frequent = std::distance(swap_mem.begin(),std::min(swap_mem.begin(), swap_mem.end()));&#10;        S.set_bit(least_frequent);&#10;&#10;        // TODO: can improve?&#10;        for (uint64_t i = 1; i &lt; k; i++) {&#10;            auto S_neg = ~S;&#10;            std::vector&lt;uint64_t&gt; candidates;&#10;            uint64_t OutMaxEdge = 0;&#10;&#10;            BitCursor v = S_neg.first_bit();&#10;            while (v.getPos() != S_neg.size()) {&#10;                auto v_edges = (g.get_neighbor_set(v.getPos()) &amp; S).n_set_bits();&#10;                if (v_edges &gt; OutMaxEdge) {&#10;                    OutMaxEdge = v_edges;&#10;                    candidates.clear();&#10;                }&#10;                candidates.push_back(v.getPos());&#10;&#10;                v = S_neg.next_bit(v);&#10;            }&#10;&#10;            auto v_min = std::ranges::min_element(candidates.begin(), candidates.end(),&#10;                [&amp;swap_mem](const uint64_t a, const uint64_t b) {&#10;                    return swap_mem[a] &lt; swap_mem[b];&#10;                });&#10;&#10;            S.set_bit(*v_min);&#10;        }&#10;        if (*std::min(swap_mem.begin(), swap_mem.end()) &gt; k) {&#10;            std::ranges::fill(swap_mem, 0);&#10;        }&#10;    }&#10;&#10;    return {S_max, false};&#10;}&#10;&#10;inline custom_bitset run_AMTS(const custom_graph&amp; g, int64_t run_time=50) {&#10;    auto max_time = std::chrono::steady_clock::now() + std::chrono::milliseconds(run_time);&#10;    // TODO: get complement for p &lt; 0.5&#10;    uint64_t Iter_Max = 100000000;&#10;    custom_bitset S_max(g.size());&#10;    custom_bitset S(g.size());&#10;    for (uint64_t k = 1; k &lt; g.size(); k++) {&#10;        if (std::chrono::steady_clock::now() &gt; max_time) break;&#10;&#10;        uint64_t L = g.size() * k;&#10;        // if brock or san L = 4 * k;&#10;        bool is_legal_k_clique = false;&#10;        std::tie(S, is_legal_k_clique) = AMTS(g, k, L, Iter_Max, max_time);&#10;        if (!is_legal_k_clique) return S_max;&#10;        S_max = S;&#10;    }&#10;    return S_max;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/stateless_BBMC.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/stateless_BBMC.h" />
              <option name="updatedContent" value="#pragma once&#10;&#10;#include &lt;vector&gt;&#10;#include &quot;stateless_graph.h&quot;&#10;&#10;inline void BB_Color(const stateless_graph&amp; g, stateless_bitset Ubb, std::vector&lt;uint64_t&gt;&amp; Ul, std::vector&lt;uint64_t&gt;&amp; C, const int64_t k_min=0) {&#10;    static stateless_bitset Qbb(g.size());&#10;    for (int64_t k = 0; Ubb; ++k) {&#10;        Qbb = Ubb;&#10;        &#10;        for (BitCursor cursor = Qbb.first_bit(); &#10;             cursor.value != Qbb.size(); &#10;             cursor = Qbb.next_bit(cursor)) {&#10;            auto v = cursor.value;&#10;            // at most we can remove vertices, so we don't need to start a new scan&#10;            Qbb -= g.get_neighbor_set(v);&#10;&#10;            if (k &gt;= k_min) {&#10;                C[v] = k;&#10;                Ul.push_back(v);&#10;            }&#10;        }&#10;        Ubb -= Qbb;&#10;    }&#10;}&#10;&#10;inline void BBMC(const stateless_graph&amp; g, stateless_bitset&amp; Ubb, std::vector&lt;std::vector&lt;uint64_t&gt;&gt;&amp; Ul, &#10;                std::vector&lt;std::vector&lt;uint64_t&gt;&gt;&amp; C, stateless_bitset&amp; S, stateless_bitset&amp; S_max, &#10;                const uint64_t depth=0) {&#10;    while (!Ul[depth].empty()) {&#10;        const auto v = Ul[depth].back();&#10;        Ul[depth].pop_back();&#10;&#10;        Ubb.unset_bit(v);&#10;&#10;        const auto S_bits = S.n_set_bits() + 1;&#10;        const auto S_max_bits = S_max.n_set_bits();&#10;&#10;        if (S_bits + C[depth][v] &gt; S_max_bits) {&#10;            S.set_bit(v);&#10;&#10;            auto candidates = Ubb &amp; g.get_neighbor_set(v);&#10;            if (candidates) {&#10;                Ul[depth+1].clear();&#10;                const int64_t k_min = S_max_bits - S_bits;&#10;&#10;                BB_Color(g, candidates, Ul[depth+1], C[depth+1], k_min);&#10;&#10;                BBMC(g, candidates, Ul, C, S, S_max, depth+1);&#10;            } else if (S_bits &gt; S_max_bits) {&#10;                S_max = S;&#10;            }&#10;&#10;            S.unset_bit(v);&#10;        }&#10;    }&#10;}&#10;&#10;inline stateless_bitset run_BBMC(const stateless_graph &amp;g, stateless_bitset Ubb) {&#10;    // initialize Ul&#10;    std::vector&lt;std::vector&lt;uint64_t&gt;&gt; Ul(g.size());&#10;&#10;    // max branching set&#10;    stateless_bitset S(g.size());&#10;    stateless_bitset S_max(g.size());&#10;&#10;    // coloring&#10;    std::vector C(g.size(), std::vector&lt;uint64_t&gt;(g.size()));&#10;&#10;    BB_Color(g, Ubb, Ul[0], C[0]);&#10;&#10;    BBMC(g, Ubb, Ul, C, S, S_max);&#10;&#10;    return g.convert_back_set(S_max);&#10;}&#10;&#10;inline stateless_bitset run_BBMC(const stateless_graph &amp;g) {&#10;    return run_BBMC(g, stateless_bitset(g.size(), true));&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/stateless_coloring.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/stateless_coloring.h" />
              <option name="updatedContent" value="#pragma once&#10;&#10;#include &lt;cstdint&gt;&#10;#include &quot;stateless_graph.h&quot;&#10;&#10;// Independent Set Sequential&#10;// computes the chromatic number of a graph using a greedy strategy (heuristic)&#10;inline uint64_t ISEQ(const stateless_graph&amp; g, stateless_bitset Ubb) {&#10;    stateless_bitset Qbb(Ubb.size());&#10;    int64_t k = 0;&#10;    for (k = 0; Ubb; ++k) {&#10;        Qbb = Ubb;&#10;        for (BitCursor cursor = Qbb.first_bit(); &#10;             cursor.value != Qbb.size(); &#10;             cursor = Qbb.next_bit(cursor)) {&#10;            // at most we can remove vertices, so we don't need to start a new scan&#10;            Qbb -= g.get_neighbor_set(cursor.value);&#10;        }&#10;        Ubb -= Qbb;&#10;    }&#10;&#10;    return k;&#10;}&#10;&#10;// Used to get the independent sets from ISEQ&#10;inline std::vector&lt;stateless_bitset&gt; ISEQ_sets(const stateless_graph&amp; g, stateless_bitset Ubb) {&#10;    std::vector&lt;stateless_bitset&gt; independent_sets;&#10;    stateless_bitset Qbb(Ubb.size());&#10;&#10;    while (Ubb) {&#10;        Qbb = Ubb;&#10;        for (BitCursor cursor = Qbb.first_bit(); &#10;             cursor.value != Qbb.size(); &#10;             cursor = Qbb.next_bit(cursor)) {&#10;            Qbb -= g.get_neighbor_set(cursor.value);&#10;        }&#10;&#10;        independent_sets.push_back(Qbb);  // Store the independent set&#10;        Ubb -= Qbb;&#10;    }&#10;&#10;    return independent_sets;&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/stateless_graph.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/stateless_graph.h" />
              <option name="updatedContent" value="#pragma once&#10;&#10;#include &lt;fstream&gt;&#10;#include &lt;numeric&gt;&#10;#include &lt;string&gt;&#10;#include &quot;custom_bitset.h&quot;&#10;#include &lt;sstream&gt;&#10;#include &lt;ranges&gt;&#10;&#10;class stateless_graph {&#10;    std::vector&lt;stateless_bitset&gt; graph;&#10;    std::vector&lt;uint64_t&gt; order_conversion;&#10;    uint64_t n_edges = 0;&#10;&#10;public:&#10;    explicit stateless_graph(const std::string&amp; filename);&#10;    explicit stateless_graph(uint64_t size);&#10;&#10;    stateless_bitset&amp; operator[](const uint64_t pos) { return graph[pos]; };&#10;&#10;    void add_edge(uint64_t u, uint64_t v);&#10;    void remove_edge(uint64_t u, uint64_t v);&#10;&#10;    [[nodiscard]] uint64_t size() const { return graph.size(); }&#10;    [[nodiscard]] uint64_t get_n_edges() const { return n_edges; }&#10;&#10;    [[nodiscard]] const stateless_bitset&amp; get_neighbor_set(const uint64_t v) const { return graph[v]; }&#10;    [[nodiscard]] stateless_bitset get_neighbor_set(const uint64_t v, const stateless_bitset&amp; set) const { return get_neighbor_set(v) &amp; set; }&#10;    [[nodiscard]] stateless_bitset get_anti_neighbor_set(const uint64_t v) const { return ~graph[v]; }&#10;    [[nodiscard]] stateless_bitset get_anti_neighbor_set(const uint64_t v, const stateless_bitset&amp; set) const { return get_anti_neighbor_set(v) &amp; set; }&#10;&#10;    [[nodiscard]] uint64_t degree() const;&#10;    [[nodiscard]] uint64_t vertex_degree(uint64_t v) const;&#10;    [[nodiscard]] float get_density() const;&#10;&#10;    [[nodiscard]] std::vector&lt;uint64_t&gt; convert_back_set(const std::vector&lt;uint64_t&gt; &amp;v) const;&#10;    [[nodiscard]] stateless_bitset convert_back_set(stateless_bitset &amp;bb) const;&#10;    [[nodiscard]] stateless_graph get_complement() const;&#10;    [[nodiscard]] stateless_graph change_order(const std::vector&lt;uint64_t&gt;&amp; order) const;&#10;    [[nodiscard]] uint64_t get_subgraph_edges(stateless_bitset &amp;subset) const;&#10;    [[nodiscard]] std::vector&lt;uint64_t&gt; get_subgraph_vertices_degree(stateless_bitset &amp;subset) const;&#10;};&#10;&#10;inline stateless_graph::stateless_graph(const std::string&amp; filename) {&#10;    std::ifstream inf(filename);&#10;    assert(inf);&#10;&#10;    std::string strInput;&#10;    while (std::getline(inf, strInput)) {&#10;        if (strInput[0] == 'p') {&#10;            uint64_t nodes;&#10;            std::istringstream(strInput.substr(7)) &gt;&gt; nodes;&#10;&#10;            graph.reserve(nodes);&#10;            order_conversion.resize(nodes);&#10;            std::iota(order_conversion.begin(), order_conversion.end(), 0);&#10;            for (uint64_t i = 0; i &lt; nodes; ++i) {&#10;                graph.emplace_back(nodes);&#10;            }&#10;        }&#10;        else if (strInput[0] == 'e') {&#10;            uint64_t node1, node2;&#10;            std::istringstream(strInput.substr(2)) &gt;&gt; node1 &gt;&gt; node2;&#10;&#10;            add_edge(node1-1, node2-1);&#10;        }&#10;    }&#10;}&#10;&#10;inline stateless_graph::stateless_graph(const uint64_t size) &#10;    : graph(size, stateless_bitset(size)), order_conversion(size) {&#10;    std::iota(order_conversion.begin(), order_conversion.end(), 0);&#10;}&#10;&#10;// Rest of the implementation follows the same pattern as custom_graph&#10;inline void stateless_graph::add_edge(const uint64_t u, const uint64_t v) {&#10;    if (u &gt;= size() || v &gt;= size() || graph[u][v]) return;&#10;&#10;    graph[u].set_bit(v);&#10;    graph[v].set_bit(u);&#10;&#10;    n_edges++;&#10;}&#10;&#10;inline void stateless_graph::remove_edge(const uint64_t u, const uint64_t v) {&#10;    if (u &gt;= size() || v &gt;= size() || !graph[u][v]) return;&#10;&#10;    graph[u].unset_bit(v);&#10;    graph[v].unset_bit(u);&#10;&#10;    n_edges--;&#10;}&#10;&#10;inline uint64_t stateless_graph::degree() const {&#10;    uint64_t degree = 0;&#10;    for (const auto&amp; edge: graph)&#10;        degree = std::max(degree, edge.degree());&#10;    return degree;&#10;}&#10;&#10;inline uint64_t stateless_graph::vertex_degree(const uint64_t v) const {&#10;    return graph[v].n_set_bits();&#10;}&#10;&#10;inline float stateless_graph::get_density() const {&#10;    return 2.0f * static_cast&lt;float&gt;(get_n_edges()) /&#10;           (static_cast&lt;float&gt;(size()) * static_cast&lt;float&gt;(size() - 1));&#10;}&#10;&#10;inline std::vector&lt;uint64_t&gt; stateless_graph::convert_back_set(const std::vector&lt;uint64_t&gt; &amp;v) const {&#10;    std::vector&lt;uint64_t&gt; set;&#10;    set.reserve(v.size());&#10;    for (const auto vertex : v) {&#10;        set.push_back(order_conversion[vertex]);&#10;    }&#10;    return set;&#10;}&#10;&#10;inline stateless_bitset stateless_graph::convert_back_set(stateless_bitset &amp;bb) const {&#10;    stateless_bitset set(bb.size());&#10;    for (BitCursor cursor = bb.first_bit(); &#10;         cursor.getPos() != bb.size(); &#10;         cursor = bb.next_bit(cursor)) {&#10;        set.set_bit(order_conversion[cursor.getPos()]);&#10;    }&#10;    return set;&#10;}&#10;&#10;inline stateless_graph stateless_graph::get_complement() const {&#10;    stateless_graph complement(*this);&#10;    std::iota(complement.order_conversion.begin(), complement.order_conversion.end(), 0);&#10;&#10;    for (uint64_t i = 0; i &lt; complement.size(); i++) {&#10;        complement.graph[i].negate();&#10;        complement.graph[i].unset_bit(i);&#10;    }&#10;&#10;    complement.n_edges = complement.size()*(complement.size()-1)/2 - get_n_edges();&#10;    return complement;&#10;}&#10;&#10;inline stateless_graph stateless_graph::change_order(const std::vector&lt;uint64_t&gt; &amp;order) const {&#10;    stateless_graph new_g(size());&#10;    new_g.order_conversion = order;&#10;&#10;    std::vector&lt;uint64_t&gt; conversion_helper(size());&#10;    for (uint64_t i = 0; i &lt; graph.size(); i++) {&#10;        conversion_helper[order[i]] = i;&#10;    }&#10;&#10;    for (uint64_t i = 0; i &lt; size(); i++) {&#10;        const auto current_vertex = conversion_helper[i];&#10;        std::vector&lt;uint64_t&gt; set = static_cast&lt;std::vector&lt;uint64_t&gt;&gt;(graph[i]);&#10;        for (auto&amp; v : set) v = conversion_helper[v];&#10;        new_g.graph[current_vertex] = stateless_bitset(set);&#10;    }&#10;&#10;    return new_g;&#10;}&#10;&#10;inline uint64_t stateless_graph::get_subgraph_edges(stateless_bitset &amp;subset) const {&#10;    uint64_t edges = 0;&#10;    for (BitCursor cursor = subset.first_bit(); &#10;         cursor.getPos() != subset.size(); &#10;         cursor = subset.next_bit(cursor)) {&#10;        edges += (get_neighbor_set(cursor.getPos()) &amp; subset).n_set_bits();&#10;    }&#10;    return edges/2;&#10;}&#10;&#10;inline std::vector&lt;uint64_t&gt; stateless_graph::get_subgraph_vertices_degree(stateless_bitset &amp;subset) const {&#10;    std::vector&lt;uint64_t&gt; d(subset.size());&#10;    for (BitCursor cursor = subset.first_bit(); &#10;         cursor.getPos() != subset.size(); &#10;         cursor = subset.next_bit(cursor)) {&#10;        d[cursor.getPos()] = vertex_degree(cursor.getPos());&#10;    }&#10;    return d;&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/stateless_sorting.h">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/stateless_sorting.h" />
              <option name="originalContent" value="#pragma once&#10;&#10;#include &lt;vector&gt;&#10;#include &lt;cstdint&gt;&#10;#include &quot;stateless_graph.h&quot;&#10;#include &quot;stateless_BBMC.h&quot;&#10;#include &quot;stateless_coloring.h&quot;&#10;&#10;// Minimum Weight Sort&#10;inline std::vector&lt;uint64_t&gt; MWS(stateless_graph g) {&#10;    std::vector&lt;uint64_t&gt; vertices(g.size());&#10;    std::vector&lt;uint64_t&gt; degrees(g.size());&#10;    std::vector&lt;uint64_t&gt; neighb_deg(g.size());&#10;    std::iota(vertices.begin(), vertices.end(), 0);&#10;&#10;    for (uint64_t i = 0; i &lt; g.size(); i++) {&#10;        degrees[i] = g[i].degree();&#10;    }&#10;    for (uint64_t i = 0; i &lt; g.size(); i++) {&#10;        for (BitCursor cursor = g[i].first_bit();&#10;             cursor.getPos() != g.size();&#10;             cursor = g[i].next_bit(cursor)) {&#10;            neighb_deg[i] += degrees[cursor.getPos()];&#10;        }&#10;    }&#10;&#10;    for (uint64_t i = 1; i &lt;= g.size(); i++) {&#10;        for (uint64_t j = 0; j &lt;= g.size()-i; j++) {&#10;            auto curr_vert = vertices[j];&#10;            neighb_deg[curr_vert] = 0;&#10;            for (BitCursor cursor = g[curr_vert].first_bit();&#10;                 cursor.getPos() != g.size();&#10;                 cursor = g[curr_vert].next_bit(cursor)) {&#10;                neighb_deg[curr_vert] += degrees[cursor.getPos()];&#10;            }&#10;        }&#10;        auto v_min = std::ranges::min_element(vertices.begin(), vertices.end()-i,&#10;            [=](const uint64_t a, const uint64_t b) {&#10;                if (degrees[a] != degrees[b]) return degrees[a] &lt; degrees[b];&#10;                return neighb_deg[a] &lt; neighb_deg[b];&#10;            });&#10;&#10;        // destructive to clean graph&#10;        for (BitCursor cursor = g[*v_min].first_bit_destructive();&#10;             cursor.getPos() != g.size();&#10;             cursor = g[*v_min].next_bit_destructive(cursor)) {&#10;            degrees[cursor.getPos()]--;&#10;            g[cursor.getPos()].unset_bit(*v_min);&#10;        }&#10;        std::iter_swap(v_min, vertices.end()-i);&#10;    }&#10;&#10;    return vertices;&#10;}&#10;&#10;// DEG_SORT&#10;// Minimum Weight Sort with Initial sorting&#10;inline std::vector&lt;uint64_t&gt; MWSI(stateless_graph g, const uint64_t p=3) {&#10;    std::vector&lt;uint64_t&gt; vertices(g.size());&#10;    std::vector&lt;uint64_t&gt; degrees(g.size());&#10;    std::vector&lt;uint64_t&gt; neighb_deg(g.size());&#10;    std::iota(vertices.begin(), vertices.end(), 0);&#10;&#10;    for (uint64_t i = 0; i &lt; g.size(); i++) {&#10;        degrees[i] = g[i].degree();&#10;    }&#10;&#10;    std::vector degrees_orig = degrees;&#10;    for (uint64_t i = 0; i &lt; g.size(); i++) {&#10;        for (BitCursor cursor = g[i].first_bit();&#10;             cursor.getPos() != g.size();&#10;             cursor = g[i].next_bit(cursor)) {&#10;            neighb_deg[i] += degrees[cursor.getPos()];&#10;        }&#10;    }&#10;&#10;    const int64_t k = g.size()/p;&#10;&#10;    for (uint64_t i = 1; i &lt;= g.size(); i++) {&#10;        for (uint64_t j = 0; j &lt;= g.size()-i; j++) {&#10;            auto curr_vert = vertices[j];&#10;            neighb_deg[curr_vert] = 0;&#10;            for (BitCursor cursor = g[curr_vert].first_bit();&#10;                 cursor.getPos() != g.size();&#10;                 cursor = g[curr_vert].next_bit(cursor)) {&#10;                neighb_deg[curr_vert] += degrees[cursor.getPos()];&#10;            }&#10;        }&#10;        auto v_min = std::ranges::min_element(vertices.begin(), vertices.end()-i,&#10;            [&amp;degrees, &amp;neighb_deg](const uint64_t a, const uint64_t b) {&#10;                if (degrees[a] != degrees[b]) return degrees[a] &lt; degrees[b];&#10;                return neighb_deg[a] &lt; neighb_deg[b];&#10;            });&#10;&#10;        for (BitCursor cursor = g[*v_min].first_bit_destructive();&#10;             cursor.getPos() != g.size();&#10;             cursor = g[*v_min].next_bit_destructive(cursor)) {&#10;            degrees[cursor.getPos()]--;&#10;            g[cursor.getPos()].unset_bit(*v_min);&#10;        }&#10;        std::iter_swap(v_min, vertices.end()-i);&#10;    }&#10;&#10;    std::ranges::sort(vertices.begin(), vertices.begin()+k,&#10;        [&amp;degrees_orig](const uint64_t a, const uint64_t b) {&#10;            return degrees_orig[a] &gt; degrees_orig[b];&#10;        });&#10;&#10;    return vertices;&#10;}&#10;&#10;inline std::pair&lt;std::vector&lt;uint64_t&gt;, uint64_t&gt; COLOUR_SORT(const stateless_graph&amp; g) {&#10;    const auto g_complement = g.get_complement();&#10;&#10;    std::vector&lt;uint64_t&gt; Ocolor;&#10;    uint64_t k = 0;&#10;    stateless_bitset W(g.size(), true);&#10;&#10;    while (W) {&#10;        auto U = run_BBMC(g_complement, W);&#10;        std::vector&lt;uint64_t&gt; U_vec = static_cast&lt;std::vector&lt;uint64_t&gt;&gt;(U);&#10;&#10;        // sort by non-increasing order&#10;        std::ranges::sort(U_vec.begin(), U_vec.end(),&#10;            [&amp;g](const uint64_t a, const uint64_t b) {&#10;                return g.vertex_degree(a) &gt; g.vertex_degree(b);&#10;            });&#10;        Ocolor.insert(Ocolor.end(), U_vec.begin(), U_vec.end());&#10;        W -= U;&#10;        k++;&#10;    }&#10;&#10;    return {Ocolor, k};&#10;}&#10;&#10;inline std::pair&lt;std::vector&lt;uint64_t&gt;, uint64_t&gt; NEW_SORT(const stateless_graph &amp;g, const uint64_t p=3) {&#10;    auto Odeg = MWSI(g, p);&#10;    auto [Ocolor, k] = COLOUR_SORT(g);&#10;&#10;    return {Odeg, k};&#10;    if (g.get_density() &lt;= 0.7) return {Odeg, k};&#10;&#10;    uint64_t color_max = 0;&#10;    const auto ordered_graph = g.change_order(Odeg);&#10;    for (uint64_t i = 1; i &lt; g.size(); i++) {&#10;        stateless_bitset Ubb(i, true);&#10;        Ubb &amp;= g.get_neighbor_set(i);&#10;        color_max = std::max(color_max, ISEQ(g, Ubb));&#10;    }&#10;&#10;    uint64_t u = 1 + color_max;&#10;&#10;    if (k &lt; u) { return {Ocolor, k}; }&#10;&#10;    return {Odeg, k};&#10;}&#10;&#10;" />
              <option name="updatedContent" value="#pragma once&#10;&#10;#include &lt;vector&gt;&#10;#include &lt;cstdint&gt;&#10;#include &quot;stateless_graph.h&quot;&#10;#include &quot;stateless_BBMC.h&quot;&#10;#include &quot;stateless_coloring.h&quot;&#10;&#10;// Minimum Weight Sort&#10;inline std::vector&lt;uint64_t&gt; MWS(stateless_graph g) {&#10;    std::vector&lt;uint64_t&gt; vertices(g.size());&#10;    std::vector&lt;uint64_t&gt; degrees(g.size());&#10;    std::vector&lt;uint64_t&gt; neighb_deg(g.size());&#10;    std::iota(vertices.begin(), vertices.end(), 0);&#10;&#10;    for (uint64_t i = 0; i &lt; g.size(); i++) {&#10;        degrees[i] = g[i].degree();&#10;    }&#10;    for (uint64_t i = 0; i &lt; g.size(); i++) {&#10;        for (BitCursor cursor = g[i].first_bit();&#10;             cursor.getPos() != g.size();&#10;             cursor = g[i].next_bit(cursor)) {&#10;            neighb_deg[i] += degrees[cursor.getPos()];&#10;        }&#10;    }&#10;&#10;    for (uint64_t i = 1; i &lt;= g.size(); i++) {&#10;        for (uint64_t j = 0; j &lt;= g.size()-i; j++) {&#10;            auto curr_vert = vertices[j];&#10;            neighb_deg[curr_vert] = 0;&#10;            for (BitCursor cursor = g[curr_vert].first_bit();&#10;                 cursor.getPos() != g.size();&#10;                 cursor = g[curr_vert].next_bit(cursor)) {&#10;                neighb_deg[curr_vert] += degrees[cursor.getPos()];&#10;            }&#10;        }&#10;        auto v_min = std::ranges::min_element(vertices.begin(), vertices.end()-i,&#10;            [=](const uint64_t a, const uint64_t b) {&#10;                if (degrees[a] != degrees[b]) return degrees[a] &lt; degrees[b];&#10;                return neighb_deg[a] &lt; neighb_deg[b];&#10;            });&#10;&#10;        // destructive to clean graph&#10;        for (BitCursor cursor = g[*v_min].first_bit_destructive();&#10;             cursor.getPos() != g.size();&#10;             cursor = g[*v_min].next_bit_destructive(cursor)) {&#10;            degrees[cursor.getPos()]--;&#10;            g[cursor.getPos()].unset_bit(*v_min);&#10;        }&#10;        std::iter_swap(v_min, vertices.end()-i);&#10;    }&#10;&#10;    return vertices;&#10;}&#10;&#10;// DEG_SORT&#10;// Minimum Weight Sort with Initial sorting&#10;inline std::vector&lt;uint64_t&gt; MWSI(stateless_graph g, const uint64_t p=3) {&#10;    std::vector&lt;uint64_t&gt; vertices(g.size());&#10;    std::vector&lt;uint64_t&gt; degrees(g.size());&#10;    std::vector&lt;uint64_t&gt; neighb_deg(g.size());&#10;    std::iota(vertices.begin(), vertices.end(), 0);&#10;&#10;    for (uint64_t i = 0; i &lt; g.size(); i++) {&#10;        degrees[i] = g[i].degree();&#10;    }&#10;&#10;    std::vector degrees_orig = degrees;&#10;    for (uint64_t i = 0; i &lt; g.size(); i++) {&#10;        for (BitCursor cursor = g[i].first_bit();&#10;             cursor.getPos() != g.size();&#10;             cursor = g[i].next_bit(cursor)) {&#10;            neighb_deg[i] += degrees[cursor.getPos()];&#10;        }&#10;    }&#10;&#10;    const int64_t k = g.size()/p;&#10;&#10;    for (uint64_t i = 1; i &lt;= g.size(); i++) {&#10;        for (uint64_t j = 0; j &lt;= g.size()-i; j++) {&#10;            auto curr_vert = vertices[j];&#10;            neighb_deg[curr_vert] = 0;&#10;            for (BitCursor cursor = g[curr_vert].first_bit();&#10;                 cursor.getPos() != g.size();&#10;                 cursor = g[curr_vert].next_bit(cursor)) {&#10;                neighb_deg[curr_vert] += degrees[cursor.getPos()];&#10;            }&#10;        }&#10;        auto v_min = std::ranges::min_element(vertices.begin(), vertices.end()-i,&#10;            [&amp;degrees, &amp;neighb_deg](const uint64_t a, const uint64_t b) {&#10;                if (degrees[a] != degrees[b]) return degrees[a] &lt; degrees[b];&#10;                return neighb_deg[a] &lt; neighb_deg[b];&#10;            });&#10;&#10;        for (BitCursor cursor = g[*v_min].first_bit_destructive();&#10;             cursor.getPos() != g.size();&#10;             cursor = g[*v_min].next_bit_destructive(cursor)) {&#10;            degrees[cursor.getPos()]--;&#10;            g[cursor.getPos()].unset_bit(*v_min);&#10;        }&#10;        std::iter_swap(v_min, vertices.end()-i);&#10;    }&#10;&#10;    std::ranges::sort(vertices.begin(), vertices.begin()+k,&#10;        [&amp;degrees_orig](const uint64_t a, const uint64_t b) {&#10;            return degrees_orig[a] &gt; degrees_orig[b];&#10;        });&#10;&#10;    return vertices;&#10;}&#10;&#10;inline std::pair&lt;std::vector&lt;uint64_t&gt;, uint64_t&gt; COLOUR_SORT(const stateless_graph&amp; g) {&#10;    const auto g_complement = g.get_complement();&#10;&#10;    std::vector&lt;uint64_t&gt; Ocolor;&#10;    uint64_t k = 0;&#10;    stateless_bitset W(g.size(), true);&#10;&#10;    while (W) {&#10;        auto U = run_BBMC(g_complement, W);&#10;        std::vector&lt;uint64_t&gt; U_vec = static_cast&lt;std::vector&lt;uint64_t&gt;&gt;(U);&#10;&#10;        // sort by non-increasing order&#10;        std::ranges::sort(U_vec.begin(), U_vec.end(),&#10;            [&amp;g](const uint64_t a, const uint64_t b) {&#10;                return g.vertex_degree(a) &gt; g.vertex_degree(b);&#10;            });&#10;        Ocolor.insert(Ocolor.end(), U_vec.begin(), U_vec.end());&#10;        W -= U;&#10;        k++;&#10;    }&#10;&#10;    return {Ocolor, k};&#10;}&#10;&#10;inline std::pair&lt;std::vector&lt;uint64_t&gt;, uint64_t&gt; NEW_SORT(const stateless_graph &amp;g, const uint64_t p=3) {&#10;    auto Odeg = MWSI(g, p);&#10;    auto [Ocolor, k] = COLOUR_SORT(g);&#10;&#10;    return {Odeg, k};&#10;    if (g.get_density() &lt;= 0.7) return {Odeg, k};&#10;&#10;    uint64_t color_max = 0;&#10;    const auto ordered_graph = g.change_order(Odeg);&#10;    for (uint64_t i = 1; i &lt; g.size(); i++) {&#10;        stateless_bitset Ubb(i, true);&#10;        Ubb &amp;= g.get_neighbor_set(i);&#10;        color_max = std::max(color_max, ISEQ(g, Ubb));&#10;    }&#10;&#10;    uint64_t u = 1 + color_max;&#10;&#10;    if (k &lt; u) { return {Ocolor, k}; }&#10;&#10;    return {Odeg, k};&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>